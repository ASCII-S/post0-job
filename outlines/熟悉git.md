# 主题：Git

## 1. Git基础概念与工作流程

### 1.1 Git基本概念

#### 1.1.1 版本控制系统
**版本控制系统的分类**
- [集中式版本控制系统（CVCS）与分布式版本控制系统（DVCS）的区别](../notes/熟悉git/集中式版本控制系统（CVCS）与分布式版本控制系统（DVCS）的区别.md)
- Git作为分布式版本控制系统的优势是什么？
- Git与其他版本控制系统（SVN、Mercurial）的主要区别

**Git的设计理念**
- Git为什么采用分布式架构？
- Git的"快照"机制与传统的"差异"机制有何不同？
- Git如何保证数据的完整性？

#### 1.1.2 Git的四个区域
**工作区（Working Directory）**
- [工作区的概念和作用是什么？](../notes/熟悉git/工作区的概念和作用是什么？.md)
- 工作区中的文件状态有哪些？
- 如何查看工作区的状态？

**暂存区（Staging Area / Index）**
- 暂存区的本质是什么？为什么需要暂存区？
- 暂存区在Git工作流程中的作用
- `.git/index`文件的作用和结构

**本地仓库（Local Repository）**
- 本地仓库的存储结构是什么？
- `.git`目录下有哪些重要文件和目录？
- 提交（commit）的本质是什么？

**远程仓库（Remote Repository）**
- 远程仓库的作用是什么？
- 本地仓库与远程仓库的关系
- 如何添加和管理多个远程仓库？

#### 1.1.3 Git对象模型
**对象类型**
- Git中有哪几种对象类型？各有什么作用？
- blob对象、tree对象、commit对象、tag对象的关系
- Git如何通过SHA-1哈希值定位对象？

**对象存储机制**
- Git对象是如何存储的？`.git/objects`目录的结构
- Git如何实现内容寻址（content-addressable）？
- 为什么相同的文件内容只存储一次？

**引用机制**
- 什么是引用（ref）？有哪些类型的引用？
- 分支（branch）和标签（tag）的本质是什么？
- HEAD指针的作用是什么？

### 1.2 Git工作流程

#### 1.2.1 基本工作流程
**文件状态转换**
- Git中文件的三种状态：已修改、已暂存、已提交
- 文件状态之间的转换流程
- `git add`、`git commit`、`git push`分别对应哪些状态转换？

**提交流程**
- 从工作区到暂存区的过程
- 从暂存区到本地仓库的过程
- 从本地仓库到远程仓库的过程

#### 1.2.2 初始化与克隆
**初始化仓库**
- `git init`命令做了什么？
- 初始化后的`.git`目录结构
- 如何将现有项目初始化为Git仓库？

**克隆仓库**
- `git clone`与`git init`的区别
- 克隆时有哪些选项？各有什么作用？
- 浅克隆（shallow clone）的使用场景

## 2. Git基本命令操作

### 2.1 仓库初始化与配置

#### 2.1.1 配置管理
**用户配置**
- 如何配置Git的用户名和邮箱？
- 全局配置、系统配置、本地配置的优先级
- 如何查看当前的Git配置？

**其他配置**
- `.gitconfig`文件的作用和位置
- 如何配置Git的默认编辑器？
- 如何配置Git的默认分支名？

#### 2.1.2 仓库初始化
**初始化命令**
- `git init`和`git init --bare`的区别
- 裸仓库（bare repository）的使用场景
- 如何将非Git项目转换为Git仓库？

### 2.2 文件操作

#### 2.2.1 添加与提交
**添加文件**
- `git add`命令的作用和用法
- `git add .`、`git add -A`、`git add -u`的区别
- 如何添加被忽略的文件？

**提交操作**
- `git commit`命令的完整流程
- 如何编写规范的提交信息？
- `git commit -m`与`git commit`的区别
- 如何修改最后一次提交？

#### 2.2.2 查看状态与差异
**状态查看**
- `git status`显示的信息含义
- 如何查看更简洁的状态信息？
- 如何查看文件的详细状态？

**差异查看**
- `git diff`与`git diff --staged`的区别
- 如何查看特定文件的差异？
- 如何查看两个提交之间的差异？
- `git diff`的输出格式如何理解？

#### 2.2.3 查看历史
**日志查看**
- `git log`的常用选项和参数
- 如何查看简洁的提交历史？
- 如何查看图形化的提交历史？
- 如何查看特定文件的提交历史？

**提交信息查看**
- `git show`命令的作用
- 如何查看特定提交的详细信息？
- 如何查看提交的统计信息？

### 2.3 文件管理

#### 2.3.1 文件删除与重命名
**删除文件**
- `git rm`与直接删除文件的区别
- 如何删除已暂存的文件？
- 如何删除已提交的文件但保留工作区文件？

**重命名文件**
- Git如何检测文件重命名？
- `git mv`命令的作用
- 如何配置Git的重命名检测阈值？

#### 2.3.2 忽略文件
**`.gitignore`文件**
- `.gitignore`文件的语法规则
- 如何忽略特定类型的文件？
- 如何忽略已被跟踪的文件？
- `.gitignore`的匹配规则和优先级

## 3. 分支管理

### 3.1 分支基础

#### 3.1.1 分支概念
**分支的本质**
- Git分支的本质是什么？
- 分支与提交的关系
- 为什么Git创建分支如此快速？

**分支指针**
- 分支指针如何指向提交？
- HEAD指针与分支指针的关系
- 如何查看当前分支指向的提交？

#### 3.1.2 分支操作
**创建分支**
- 如何创建新分支？
- `git branch`与`git checkout -b`的区别
- 如何基于特定提交创建分支？

**切换分支**
- `git checkout`与`git switch`的区别
- 切换分支时Git做了什么？
- 什么情况下无法切换分支？

**删除分支**
- 如何删除本地分支？
- 如何删除远程分支？
- 什么情况下无法删除分支？

### 3.2 分支合并

#### 3.2.1 合并基础
**合并类型**
- 快进合并（fast-forward）与三方合并（three-way merge）的区别
- 什么情况下会发生快进合并？
- 如何强制使用三方合并？

**合并操作**
- `git merge`命令的执行流程
- 如何合并指定分支到当前分支？
- 合并冲突是如何产生的？

#### 3.2.2 合并策略
**合并策略类型**
- Git有哪些合并策略？各适用于什么场景？
- `recursive`策略的工作原理
- `ours`和`theirs`策略的使用场景

**合并选项**
- `--no-ff`选项的作用
- `--squash`选项的作用和使用场景
- `--no-commit`选项的作用

### 3.3 变基（Rebase）

#### 3.3.1 Rebase基础
**Rebase概念**
- Rebase与Merge的区别
- Rebase的工作原理是什么？
- 为什么说Rebase会"重写历史"？

**Rebase操作**
- `git rebase`命令的基本用法
- 如何将当前分支变基到目标分支？
- 交互式Rebase（`git rebase -i`）的作用

#### 3.3.2 交互式Rebase
**交互式操作**
- 交互式Rebase可以执行哪些操作？
- `pick`、`reword`、`edit`、`squash`、`drop`的含义
- 如何修改历史提交信息？
- 如何合并多个提交？

**Rebase的风险**
- 为什么不能在公共分支上使用Rebase？
- Rebase可能带来的问题
- 如何安全地使用Rebase？

### 3.4 分支工作流

#### 3.4.1 常见工作流
**Git Flow**
- Git Flow工作流的核心概念
- 主分支、开发分支、功能分支、发布分支、热修复分支的作用
- Git Flow的优缺点

**GitHub Flow**
- GitHub Flow工作流的特点
- 与Git Flow的区别
- 适用于什么类型的项目？

**Trunk-based Development**
- 主干开发模式的特点
- 与分支开发模式的区别
- 适用于什么场景？

#### 3.4.2 分支命名规范
**命名约定**
- 常见的分支命名规范有哪些？
- 如何通过分支名表达分支的用途？
- 分支命名的最佳实践

## 4. 远程仓库操作

### 4.1 远程仓库管理

#### 4.1.1 远程仓库配置
**添加远程仓库**
- 如何添加远程仓库？
- `origin`名称的由来和约定
- 如何添加多个远程仓库？

**查看远程仓库**
- 如何查看已配置的远程仓库？
- `git remote -v`显示的信息含义
- 如何查看远程仓库的详细信息？

**修改远程仓库**
- 如何修改远程仓库的URL？
- 如何重命名远程仓库？
- 如何删除远程仓库？

#### 4.1.2 远程分支
**远程分支概念**
- 远程分支的本质是什么？
- `origin/master`与`master`的区别
- 远程跟踪分支（remote-tracking branch）的作用

**远程分支操作**
- 如何查看远程分支？
- 如何创建基于远程分支的本地分支？
- 如何设置本地分支跟踪远程分支？

### 4.2 推送与拉取

#### 4.2.1 推送操作
**基本推送**
- `git push`命令的完整语法
- 如何推送本地分支到远程仓库？
- 如何推送所有分支？

**推送选项**
- `-u`选项的作用
- `--force`和`--force-with-lease`的区别
- 什么情况下需要使用强制推送？

**推送拒绝**
- 为什么推送会被拒绝？
- 如何解决推送冲突？
- 推送前应该做什么检查？

#### 4.2.2 拉取操作
**Pull与Fetch**
- `git pull`与`git fetch`的区别
- `git pull`等价于什么操作？
- 什么时候应该使用`fetch`而不是`pull`？

**Fetch操作**
- `git fetch`的作用
- Fetch后如何查看远程分支的更新？
- 如何Fetch特定的远程分支？

**Pull操作**
- `git pull`的执行流程
- Pull时如何选择合并策略？
- Pull可能产生冲突的情况

### 4.3 协作工作流

#### 4.3.1 多人协作
**协作流程**
- 多人协作的基本流程是什么？
- 如何避免推送冲突？
- 如何处理其他人的提交？

**冲突处理**
- 远程仓库冲突是如何产生的？
- 如何解决远程分支的冲突？
- 协作中的最佳实践

#### 4.3.2 Fork与Pull Request
**Fork工作流**
- Fork的概念和作用
- Fork与Clone的区别
- 如何同步Fork的仓库？

**Pull Request流程**
- Pull Request（PR）的工作流程
- 如何创建和提交PR？
- 如何审查和处理PR？

## 5. 冲突解决

### 5.1 冲突产生

#### 5.1.1 冲突原因
**冲突类型**
- [Git中哪些操作可能产生冲突？](../notes/熟悉git/Git中哪些操作可能产生冲突？.md)
- 合并冲突与Rebase冲突的区别
- 什么情况下不会产生冲突？

**冲突检测**
- Git如何检测冲突？
- 冲突标记（`<<<<<<<`、`=======`、`>>>>>>>`）的含义
- 如何查看冲突的详细信息？

#### 5.1.2 冲突场景
**合并冲突**
- 合并时冲突的产生条件
- 如何查看合并冲突的文件？
- 合并冲突的解决流程

**Rebase冲突**
- Rebase时冲突的特点
- 如何解决Rebase冲突？
- Rebase冲突与合并冲突的处理差异

### 5.2 冲突解决

#### 5.2.1 解决流程
**手动解决**
- 如何手动编辑冲突文件？
- 解决冲突后需要做什么？
- 如何标记冲突已解决？

**工具辅助**
- 有哪些冲突解决工具？
- 如何配置合并工具？
- 三路合并工具的工作原理

#### 5.2.2 冲突策略
**选择策略**
- 如何选择保留哪一方的更改？
- `--ours`和`--theirs`选项的使用
- 如何部分接受双方的更改？

**避免冲突**
- 如何减少冲突的发生？
- 团队协作中避免冲突的最佳实践
- 代码审查在减少冲突中的作用

## 6. 撤销与回滚操作

### 6.1 工作区撤销

#### 6.1.1 撤销修改
**撤销工作区修改**
- `git checkout -- <file>`的作用
- `git restore`命令的用法
- 如何撤销工作区所有文件的修改？

**撤销已暂存文件**
- 如何将文件从暂存区移除但保留修改？
- `git reset HEAD`与`git restore --staged`的区别
- 如何清空整个暂存区？

### 6.2 提交回滚

#### 6.2.1 Reset操作
**Reset类型**
- `--soft`、`--mixed`、`--hard`三种模式的区别
- 每种模式影响哪些区域？
- 如何选择合适Reset模式？

**Reset操作**
- `git reset HEAD~1`的作用
- 如何回滚到指定提交？
- Reset的风险和注意事项

#### 6.2.2 Revert操作
**Revert概念**
- Revert与Reset的区别
- Revert如何创建新提交？
- 为什么Revert更安全？

**Revert操作**
- 如何Revert单个提交？
- 如何Revert合并提交？
- Revert可能产生冲突的情况

### 6.3 历史修改

#### 6.3.1 修改提交
**修改最后一次提交**
- 如何修改最后一次提交信息？
- 如何向最后一次提交添加文件？
- `--amend`选项的作用

**修改历史提交**
- 如何使用交互式Rebase修改历史提交？
- 修改历史提交的风险
- 如何安全地修改已推送的提交？

#### 6.3.2 删除提交
**删除提交**
- 如何删除历史中的某个提交？
- 删除提交对后续提交的影响
- 如何删除已推送的提交？

## 7. 高级操作

### 7.1 Stash操作

#### 7.1.1 Stash基础
**Stash概念**
- Stash的作用和使用场景
- Stash如何存储未提交的更改？
- Stash与提交的区别

**Stash操作**
- 如何创建Stash？
- 如何查看Stash列表？
- 如何应用Stash？
- `git stash pop`与`git stash apply`的区别

#### 7.1.2 Stash管理
**Stash选项**
- 如何创建带描述的Stash？
- 如何Stash未跟踪的文件？
- 如何Stash特定文件？

**Stash清理**
- 如何删除Stash？
- 如何清空所有Stash？
- Stash的存储位置

### 7.2 Cherry-pick

#### 7.2.1 Cherry-pick基础
**Cherry-pick概念**
- Cherry-pick的作用
- Cherry-pick与Merge的区别
- 什么场景下使用Cherry-pick？

**Cherry-pick操作**
- 如何Cherry-pick单个提交？
- 如何Cherry-pick多个提交？
- Cherry-pick可能产生冲突的情况

#### 7.2.2 Cherry-pick应用
**选择性应用**
- 如何从其他分支选择性地应用提交？
- Cherry-pick后提交的SHA-1会变化吗？
- 如何Cherry-pick一个范围的提交？

### 7.3 其他高级操作

#### 7.3.1 Bisect
**二分查找**
- `git bisect`的作用和使用场景
- 如何使用Bisect查找引入bug的提交？
- Bisect的工作流程

#### 7.3.2 Submodule
**子模块概念**
- Git Submodule的作用
- 什么时候需要使用Submodule？
- Submodule的优缺点

**子模块操作**
- 如何添加Submodule？
- 如何更新Submodule？
- 如何克隆包含Submodule的仓库？

#### 7.3.3 Archive
**归档操作**
- `git archive`的作用
- 如何创建项目的归档文件？
- 归档与Clone的区别

## 8. Git底层原理

### 8.1 对象存储

#### 8.1.1 对象类型详解
**Blob对象**
- Blob对象存储什么内容？
- 相同内容的文件如何共享Blob对象？
- Blob对象的命名规则

**Tree对象**
- Tree对象的结构和作用
- Tree对象如何组织目录结构？
- Tree对象与文件系统的对应关系

**Commit对象**
- Commit对象包含哪些信息？
- Commit对象如何指向Tree对象？
- 如何查看Commit对象的原始内容？

**Tag对象**
- 轻量级标签与附注标签的区别
- Tag对象的结构
- 什么时候应该使用附注标签？

#### 8.1.2 对象存储机制
**存储格式**
- Git对象如何压缩存储？
- `.git/objects`目录的组织结构
- 对象如何通过SHA-1定位？

**引用计数**
- Git如何实现对象共享？
- 什么时候对象会被垃圾回收？
- `git gc`命令的作用

### 8.2 索引机制

#### 8.2.1 索引结构
**索引文件**
- `.git/index`文件的作用
- 索引文件的结构是什么？
- 索引如何跟踪文件状态？

**索引更新**
- `git add`如何更新索引？
- 索引与工作区、仓库的关系
- 如何查看索引的内容？

#### 8.2.2 索引操作
**索引管理**
- 如何直接操作索引？
- `git ls-files`命令的作用
- 索引在合并中的作用

### 8.3 引用系统

#### 8.3.1 引用类型
**分支引用**
- 分支引用存储在哪里？
- `.git/refs/heads`目录的作用
- 分支引用如何指向提交？

**远程引用**
- 远程引用与本地引用的区别
- `.git/refs/remotes`目录的作用
- 远程引用如何更新？

**标签引用**
- 标签引用的存储位置
- 标签引用与Tag对象的区别
- 如何创建和删除标签？

#### 8.3.2 HEAD机制
**HEAD指针**
- HEAD指针的本质
- 分离HEAD（detached HEAD）状态是什么？
- 如何从分离HEAD状态恢复？

**符号引用**
- HEAD如何指向当前分支？
- `.git/HEAD`文件的内容
- 符号引用与直接引用的区别

## 9. Git配置与钩子

### 9.1 Git配置

#### 9.1.1 配置级别
**配置优先级**
- 系统级、全局级、本地级配置的优先级
- 如何查看各级别的配置？
- 如何删除特定配置？

**常用配置**
- 如何配置别名（alias）？
- 如何配置默认分支名？
- 如何配置推送行为？

#### 9.1.2 高级配置
**性能优化**
- 如何配置Git的性能参数？
- 如何优化大仓库的性能？
- `core.preloadindex`等配置的作用

**行为配置**
- 如何配置自动换行符处理？
- 如何配置文件大小限制？
- 如何配置合并工具？

### 9.2 Git钩子

#### 9.2.1 钩子类型
**客户端钩子**
- 有哪些客户端钩子？
- `pre-commit`钩子的作用和使用场景
- `commit-msg`钩子的作用
- `post-commit`钩子的使用场景

**服务端钩子**
- 有哪些服务端钩子？
- `pre-receive`钩子的作用
- `update`钩子的使用场景
- `post-receive`钩子的作用

#### 9.2.2 钩子实现
**钩子脚本**
- 钩子脚本的位置和命名规则
- 如何编写钩子脚本？
- 钩子脚本的权限要求

**常用钩子**
- 如何实现提交信息检查？
- 如何实现代码风格检查？
- 如何实现自动部署？

## 10. 团队协作与最佳实践

### 10.1 提交规范

#### 10.1.1 提交信息规范
**提交信息格式**
- 如何编写清晰的提交信息？
- 提交信息的标题和正文规范
- 常见的提交信息约定（Conventional Commits）

**提交粒度**
- 如何确定合适的提交粒度？
- 一个提交应该包含哪些更改？
- 如何拆分过大的提交？

#### 10.1.2 提交策略
**提交频率**
- 应该多久提交一次？
- 提交前应该做什么检查？
- 如何保持提交历史的清晰？

### 10.2 分支策略

#### 10.2.1 分支命名
**命名规范**
- 如何制定分支命名规范？
- 功能分支、修复分支、发布分支的命名约定
- 分支命名的最佳实践

#### 10.2.2 分支管理
**分支生命周期**
- 如何管理分支的创建和删除？
- 何时应该删除分支？
- 如何清理已合并的分支？

**保护分支**
- 如何保护重要分支？
- 分支保护规则的作用
- 如何配置分支保护？

### 10.3 代码审查

#### 10.3.1 审查流程
**Pull Request流程**
- 如何创建高质量的PR？
- PR描述应该包含哪些内容？
- 如何审查PR？

**审查要点**
- 代码审查应该关注哪些方面？
- 如何提供有建设性的反馈？
- 如何处理审查意见？

#### 10.3.2 协作工具
**平台使用**
- GitHub、GitLab、Bitbucket的主要功能
- 如何使用Issue跟踪问题？
- 如何使用Wiki管理文档？

### 10.4 问题排查

#### 10.4.1 常见问题
**推送问题**
- 推送被拒绝的常见原因
- 如何解决认证问题？
- 如何处理网络问题？

**合并问题**
- 如何解决复杂的合并冲突？
- 如何恢复误删的分支？
- 如何找回丢失的提交？

#### 10.4.2 调试技巧
**日志分析**
- 如何使用`git log`排查问题？
- 如何查看文件的历史变更？
- 如何使用`git reflog`恢复操作？

**状态检查**
- 如何检查仓库的健康状态？
- 如何验证对象的完整性？
- 如何检查配置问题？

