# 精通C++ 面试大纲

---

## 面试目标
全面考察应届生对C++语言的掌握程度，从基础语法到高级特性，从理论知识到实际应用能力，确保候选人具备扎实的C++编程功底。

## 面试时长
建议总时长：90-120分钟

## 考核维度权重
- 基础语法和概念：12%
- 面向对象编程：13%
- 内存管理：13%
- STL和模板：12%
- C++并发编程：18%
- 网络编程：15%
- 现代C++特性：8%
- 性能优化：4%
- 实际编程能力：5%
---

## 第一部分：C++基础概念和语法（15-20分钟）

### 1.1 语言基础
**考核要点：**
- C++与C的区别和联系
- 编译过程和链接机制
- 头文件和源文件的组织

**核心问题：**
1. **编译链接过程**
   - [描述C++程序从源代码到可执行文件的完整过程](../notes/C++/C++程序从源代码到可执行文件的完整过程.md)
   - 解释预处理、编译、汇编、链接各阶段的作用
   - [使用编译优化选项时，哪个或哪些阶段得到了优化？](../notes/C++/使用编译优化选项时，哪个或哪些阶段得到了优化？.md)
   - [静态链接和动态链接](../notes/C++/静态链接和动态链接.md)
   - [什么是符号表？链接时如何解决符号引用？](../notes/C++/什么是符号表？链接时如何解决符号引用？.md)
   - [重定位表怎么工作的？](../notes/C++/重定位表怎么工作的？.md)
   - [定义一个100大小的数组，但是通过下标访问101位置，会发生什么？](../notes/C++/定义一个100大小的数组，但是通过下标访问101位置，会发生什么？.md)

2. **头文件机制**
   - [#include的工作原理](../notes/C++/include的工作原理.md)
   - 如何防止头文件重复包含？比较`#pragma once`和`#ifndef`的优缺点
   - 前向声明的作用和使用场景

3. **名空间机制**
   - 为什么需要命名空间？如何避免命名空间？[为什么需要命名空间？如何避免命名空间？](../notes/C++/为什么需要命名空间？如何避免命名空间？.md)
   - `using`声明和`using`指令的区别
   - ADL（参数依赖查找）是什么？举例说明

### 1.2 数据类型和变量
**考核要点：**
- 基本数据类型的特点和使用
- 类型转换机制
- 常量和变量的声明

**核心问题：**
1. **类型系统**
   - C++中有哪些基本数据类型？各占多少字节？
   - [指针和引用的区别](../notes/C++/指针和引用的区别.md)
   - [`int`、`long`、`long long`在不同平台上的差异](../notes/C++/int、long、long_long在不同平台上的差异.md)
   - `size_t`和`ptrdiff_t`的用途和区别

2. **类型转换**
   - 隐式类型转换的规则和潜在问题
   - [四种显式类型转换的区别和使用场景](../notes/C++/四种显式类型转换的区别和使用场景.md)
   - `const_cast`什么时候使用？有什么风险？

3. **常量机制**
   - [const关键字](../notes/C++/const关键字.md)
   - [constexpr与const的区别](../notes/C++/constexpr与const的区别.md)
   - 编译期常量与运行期常量的区别
   - [static关键字](../notes/C++/static关键字.md)
   - [静态局部变量，全局变量，局部变量](../notes/C++/静态局部变量，全局变量，局部变量.md)
4. **其他关键字**
   - [define和typedef的区别](../notes/C++/define和typedef的区别.md)
---

## 第二部分：面向对象编程（20-25分钟）

### 2.1 类和对象基础
**考核要点：**
- 类的定义和对象的创建
- 构造函数和析构函数
- 访问控制机制

**核心问题：**
1. **构造和析构**
   - 默认构造函数什么时候会被编译器生成？
   - 构造函数初始化列表的作用和必要性
   - 析构函数的调用时机和虚析构函数的重要性
   - [explicit关键字](../notes/C++/explicit关键字.md)
   - [析构函数可以抛出异常么](../notes/C++/析构函数可以抛出异常么.md)

2. **拷贝控制**
   - 什么是"三五法则"？为什么重要？
   - [深拷贝和浅拷贝的区别，什么时候需要深拷贝？](../notes/C++/深拷贝和浅拷贝的区别，什么时候需要深拷贝？.md)
   - 移动构造函数和移动赋值运算符的作用

3. **访问控制**
   - `public`、`private`、`protected`的访问规则
   - `friend`关键字的使用场景和设计考量
   - 类的封装性如何体现？
   - [.和->的区别](../notes/C++/._和->的区别.md)

### 2.2 继承和多态
**考核要点：**
- 继承机制和访问控制
- 虚函数和多态实现
- 抽象类和接口设计

**核心问题：**
1. **继承机制**
   - 公有继承、私有继承、保护继承的区别和使用场景
   - 多重继承的问题和解决方案
   - 虚继承解决了什么问题？实现原理是什么？
   - [类继承中的内存布局](../notes/C++/类继承中的内存布局.md)

2. **多态实现**
   - [动态多态和静态多态的区别](../notes/C++/动态多态和静态多态的区别.md)
   - [虚函数的实现机制（虚函数表）](../notes/C++/虚函数的实现机制（虚函数表）.md)
   - [调用虚函数的执行流程](../notes/C++/调用虚函数的执行流程.md)
   - [纯虚函数和抽象类的作用](../notes/C++/纯虚函数和抽象类的作用.md)
   - [简述虚析构函数及作用](../notes/C++/简述虚析构函数及作用.md)
   - [为什么没有虚构造函数](../notes/C++/为什么没有虚构造函数.md)
   - 虚函数的性能开销和优化考虑

3. **高级继承概念**
   - RTTI（运行时类型信息）的使用
   - [`dynamic_cast`的工作原理](../notes/C++/dynamic_cast的工作原理.md)
   - 接口设计的最佳实践

---

## 第三部分：内存管理（15-20分钟）

### 3.1 内存布局和管理
**考核要点：**
- 程序内存布局
- 动态内存分配
- 内存泄漏和野指针问题

**核心问题：**
1. **内存区域**
   - [栈、堆、全局区、常量区的特点和用途](../notes/C++/栈、堆、全局区、常量区的特点和用途.md)
   - [栈溢出和堆溢出的原因和预防](../notes/C++/栈溢出和堆溢出的原因和预防.md)
   - [指针和引用的区别](../notes/C++/指针和引用的区别.md)
   - 内存对齐的原理和影响

2. **动态内存管理**
   - [new和malloc的区别](../notes/C++/new和malloc的区别.md)
   - `new`/`delete`与`malloc`/`free`的区别
   - [new[]和delete[]的使用注意事项](../notes/C++/new[]和delete[]的使用注意事项.md)
   - [内存池和对象池的设计思想](../notes/C++/内存池和对象池的设计思想.md)

3. **常见内存问题**
   - 内存泄漏的检测和预防方法
   - [野指针和悬空指针的区别](../notes/C++/野指针和悬空指针的区别.md)
   - 缓冲区溢出的危害和防护

### 3.2 智能指针和RAII
**考核要点：**
- RAII设计模式
- 智能指针的使用
- 资源管理最佳实践

**核心问题：**
1. **RAII原则**
   - RAII的核心思想和优势
   - [如何用RAII管理各种资源（内存、文件、锁等）](../notes/C++/如何用RAII管理各种资源（内存、文件、锁等）.md)
   - 异常安全性的三个级别

2. **智能指针详解**
   - [`unique_ptr`、`shared_ptr`、`weak_ptr`的使用场景](../notes/C++/unique_ptr、shared_ptr、weak_ptr的使用场景.md)
   - [`unique_ptr`](../notes/C++/unique_ptr.md)
   - [`shared_ptr`和`weak_ptr`](../notes/C++/shared_ptr和weak_ptr.md)
   - [设计一个简单的shared_ptr](../notes/C++/设计一个简单的shared_ptr.md)
   - [循环引用问题及解决方案](../notes/C++/循环引用问题及解决方案.md)
   - [删除器是什么](../notes/C++/删除器是什么.md)
   - 自定义删除器的使用

---

## 第四部分：STL和模板编程（15-20分钟）

### 4.1 STL容器和算法
**考核要点：**
- 常用容器的特点和选择
- 迭代器的使用
- STL算法的应用

**核心问题：**
1. **容器选择**
   - `vector`、`list`、`deque`的性能特点和适用场景
   - [`map`、`unordered_map`的实现原理和性能差异](../notes/C++/map、unordered_map的实现原理和性能差异.md)
   - [容器的内存管理和扩容策略](../notes/C++/容器的内存管理和扩容策略.md)

2. **迭代器系统**
   - [五种迭代器类型的特点和使用](../notes/C++/五种迭代器类型的特点和使用.md)
   - [迭代器失效的原因和预防](../notes/C++/迭代器失效的原因和预防.md)
   - 自定义迭代器的实现要点

3. **算法库使用**
   - 常用算法的复杂度分析
   - 函数对象和lambda表达式的使用
   - 算法的定制和扩展

### 4.2 模板编程
**考核要点：**
- 函数模板和类模板
- 模板特化和偏特化
- 模板元编程基础

**核心问题：**
1. **模板基础**
   - 模板的实例化过程和编译期多态
   - 模板参数推导的规则
   - 模板的二次编译检查

2. **高级模板技术**
   - 特化和偏特化的使用场景
   - SFINAE技术的应用
   - 变参模板的使用

---

## 第五部分：C++并发编程（20-25分钟）

### 5.1 多线程基础
**考核要点：**
- 线程的创建和管理
- 线程同步机制
- 线程间通信

**核心问题：**
1. **线程生命周期**
   - [std::thread的创建和销毁](../notes/C++/std::thread的创建和销毁.md)
   - [`join()`和`detach()`的区别和使用场景](../notes/C++/join()和detach()的区别和使用场景.md)
   - [多线程中的子线程抛异常会发生什么？](../notes/C++/多线程中的子线程抛异常会发生什么？.md)
   - 线程的可连接状态和资源管理
   - 如何安全地传递参数给线程函数？

2. **线程同步基础**
   - [什么是竞态条件？如何避免？](../notes/C++/什么是竞态条件？如何避免？.md)
   - [死锁的四个必要条件和预防策略](../notes/C++/死锁的四个必要条件和预防策略.md)
   - [`std::mutex`的基本使用和RAII封装](../notes/C++/mutex的基本使用和RAII封装.md)
   - 递归锁`std::recursive_mutex`的使用场景

3. **锁的管理**
   - [`std::lock_guard`和`std::unique_lock`的区别](../notes/C++/lock_guard和std::unique_lock的区别.md)
   - [延迟加锁是什么](../notes/C++/延迟加锁是什么.md)
   - `std::shared_lock`的作用和读写锁实现
   - 如何避免锁的性能开销？
   - 锁的粒度设计原则

### 5.2 高级同步机制
**考核要点：**
- 条件变量和信号量
- 原子操作和内存模型
- 线程池设计

**核心问题：**
1. **条件变量**
   - [`std::condition_variable`的使用模式](../notes/C++/condition_variable的使用模式.md)
   - 为什么条件变量需要配合互斥锁使用？
   - 虚假唤醒问题及其解决方案
   - [生产者-消费者模式的实现](../notes/C++/生产者-消费者模式的实现.md)
   - [实现两个线程交替打印0-1000](../notes/C++/实现两个线程交替打印0-1000.md)

2. **原子操作**
   - [`std::atomic`的基本使用](../notes/C++/atomic的基本使用.md)
   - [内存序（memory ordering）的六种类型](../notes/C++/内存序（memory_ordering）的六种类型.md)
   - `memory_order_relaxed`、`memory_order_acquire`、`memory_order_release`的区别
   - 无锁编程的优势和挑战
   - ABA问题及其解决方案

3. **高级并发工具**
   - `std::future`和`std::promise`的使用
   - `std::async`的不同启动策略
   - `std::packaged_task`的应用场景
   - 线程池的设计原理和实现要点

### 5.3 并发编程实践
**考核要点：**
- 线程安全的数据结构设计
- 性能优化和调试技巧
- 常见并发模式

**核心问题：**
1. **线程安全设计**
   - 如何设计线程安全的单例模式？
   - 线程安全的队列如何实现？
   - 读写锁在什么场景下比互斥锁更高效？
   - 如何实现一个线程安全的引用计数？

2. **性能考虑**
   - 上下文切换的开销和优化
   - 缓存一致性问题对多线程性能的影响
   - 如何选择合适的线程数量？
   - NUMA架构对并发程序的影响

3. **调试和测试**
   - 如何调试多线程程序？
   - 常用的线程调试工具
   - 如何检测死锁和竞态条件？
   - 压力测试和性能分析方法

### 5.4 现代并发特性
**考核要点：**
- C++20协程基础
- 并行算法
- 内存模型深入理解

**核心问题：**
1. **协程入门**
   - 协程与线程的区别
   - `co_await`、`co_yield`、`co_return`的基本使用
   - 协程的性能优势和适用场景
   - 协程的调度和执行模型

2. **并行算法**
   - `std::execution`策略的使用
   - 并行版本的STL算法性能特点
   - 如何选择合适的执行策略？
   - 并行算法的异常处理

3. **内存模型深入**
   - CPU缓存一致性协议
   - 内存屏障的作用机制
   - 弱内存模型vs强内存模型
   - 如何分析多线程程序的内存访问模式？

---

## 第六部分：C++网络编程（15-20分钟）

### 6.1 网络编程基础
**考核要点：**
- Socket编程基础
- TCP/UDP协议理解
- 网络I/O模型

**核心问题：**
1. **Socket编程基础**
   - [Socket的创建、绑定、监听、连接流程](../notes/C++/Socket的创建、绑定、监听、连接流程.md)
   - `socket()`、`bind()`、`listen()`、`accept()`、`connect()`函数的作用
   - 网络字节序与主机字节序的转换（`htonl`、`ntohl`等）
   - `sockaddr_in`结构体的使用
   - 如何处理Socket编程中的错误？

2. **TCP vs UDP**
   - [TCP和UDP的区别和适用场景](../notes/C++/TCP和UDP的区别和适用场景.md)
   - TCP的三次握手和四次挥手过程
   - [TCP的流控制和拥塞控制机制](../notes/C++/TCP的流控制和拥塞控制机制.md)
   - UDP如何实现可靠传输？
   - 半关闭连接的概念和应用

3. **地址和端口管理**
   - IP地址的表示和转换（`inet_addr`、`inet_ntoa`）
   - 端口号的作用和分配规则
   - `SO_REUSEADDR`、`SO_REUSEPORT`选项的作用
   - 如何处理端口占用问题？

### 6.2 高级网络I/O技术
**考核要点：**
- 阻塞与非阻塞I/O
- I/O多路复用技术
- 异步I/O编程

**核心问题：**
1. **I/O模型对比**
   - [阻塞I/O、非阻塞I/O、I/O多路复用、异步I/O的区别](../notes/C++/阻塞I/O、非阻塞I/O、I/O多路复用、异步I/O的区别.md)
   - 各种I/O模型的性能特点和适用场景
   - 同步I/O与异步I/O的本质区别
   - 为什么需要非阻塞I/O？

2. **I/O多路复用**
   - [`select()`、`poll()`、`epoll()`的工作原理和区别](../notes/C++/select()、poll()、epoll()的工作原理和区别.md)
   - `epoll`的ET（边缘触发）和LT（水平触发）模式
   - 如何处理`epoll`中的事件？
   - [`epoll`为什么比`select`和`poll`性能更好？](../notes/C++/epoll为什么比select和poll性能更好？.md)
   - 跨平台I/O多路复用的解决方案

3. **异步I/O编程**
   - Linux的AIO机制和使用方法
   - `io_uring`的基本概念和优势
   - 异步I/O的回调处理模式
   - 如何设计异步网络库的架构？

---

## 第七部分：现代C++特性（10-15分钟）

### 7.1 C++11/14核心特性
**考核要点：**
- 右值引用和移动语义
- 自动类型推导
- 范围for循环

**核心问题：**
1. **移动语义**
   - [左值和右值的区别](../notes/C++/左值和右值的区别.md)
   - [右值引用](../notes/C++/右值引用.md)
   - [右值引用与移动语义](../notes/C++/右值引用与移动语义.md)
   - 移动构造函数的实现和使用
   - [移动语义和std::move](../notes/C++/移动语义和std::move.md)
   - [完美转发的原理和应用](../notes/C++/完美转发的原理和应用.md)

2. **类型推导**
   - [`auto`关键字的使用场景和限制](../notes/C++/auto关键字的使用场景和限制.md)
   - [`decltype`的推导规则](../notes/C++/decltype的推导规则.md)
   - [尾置返回类型的作用](../notes/C++/尾置返回类型的作用.md)
   - [通用引用](../notes/C++/通用引用.md)

### 7.2 C++17/20新特性
**考核要点：**
- 结构化绑定
- 概念和约束
- 协程基础

**核心问题：**
1. **实用特性**
   - `std::optional`和`std::variant`的使用
   - 结构化绑定的应用场景
   - `if constexpr`的编译期分支

2. **现代特性**
   - Concepts的作用和语法
   - 协程的基本概念和使用
   - 模块系统的优势

---

## 第八部分：性能优化和最佳实践（5-10分钟）

### 8.1 性能优化技术
**考核要点：**
- 编译器优化
- 缓存友好的代码
- 并发编程基础

**核心问题：**
1. **优化策略**
   - 编译器优化的类型和限制
   - 内联函数的使用和注意事项
   - 分支预测和循环优化

2. **代码优化实践**
   - 避免不必要的拷贝和临时对象
   - 合理使用移动语义
   - 模板特化优化

### 8.2 代码质量和设计模式
**考核要点：**
- 常用设计模式
- 代码规范和风格
- 调试和测试方法

**核心问题：**
1. **设计模式应用**
   - 单例模式的线程安全实现
   - [工厂模式和抽象工厂模式](../notes/C++/工厂模式和抽象工厂模式.md)
   - 观察者模式的C++实现

---

## 面试评分标准

### 优秀（90-100分）
- 深入理解C++核心概念和机制
- 熟练掌握现代C++特性和最佳实践
- 精通多线程编程和并发安全设计
- 具备扎实的网络编程基础，理解各种I/O模型和性能优化技术
- 能够分析复杂的代码问题并提供优雅的解决方案
- 具备良好的代码设计能力和性能优化意识

### 良好（80-89分）
- 掌握C++基础知识和面向对象编程
- 了解STL和模板编程的基本使用
- 理解多线程编程基础概念和同步机制
- 掌握Socket编程基础，了解常见的网络I/O技术
- 能够识别常见的代码问题并给出解决方案
- 对现代C++特性有一定了解

### 合格（70-79分）
- 具备C++基础语法和编程能力
- 理解基本的面向对象概念
- 了解基本的线程概念，但缺乏实际经验
- 对网络编程有基本认识，了解TCP/UDP基础概念
- 能够完成简单的编程任务
- 对内存管理有基本认识

### 不合格（<70分）
- C++基础知识不扎实
- 缺乏面向对象编程经验
- 对并发编程和网络编程缺乏基本理解
- 代码质量和规范性较差
- 无法独立解决编程问题

---

## 面试官注意事项

1. **循序渐进**：从基础概念开始，根据候选人表现调整难度
2. **理论结合实践**：不仅考察理论知识，更要关注实际编程能力
3. **关注思路**：重点考察解决问题的思路和方法，而非死记硬背
4. **适度引导**：在候选人遇到困难时给予适当提示，观察学习能力
5. **全面评估**：结合技术能力、沟通能力、学习态度等多个维度

## 常见追问方向

- 对于回答正确的问题，可以深入追问实现细节或应用场景
- 对于回答不完整的问题，可以从不同角度继续提问
- 结合实际项目经验，询问具体的使用场景和遇到的问题
- 网络编程方面可以从性能优化、错误处理、安全性等角度深入
- 并发编程可以结合网络编程场景，考察线程池、异步I/O等综合应用
- 关注候选人的学习方法和技术成长路径
- 可以询问对开源网络库（如muduo、libevent、boost.asio）的了解和使用经验
