---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/反转链表.md
related_outlines: []
---
# 反转链表

## 题目描述

给你单链表的头节点 `head`，请你反转链表，并返回反转后的链表。

**示例 1：**
```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**
```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**
```
输入：head = []
输出：[]
```

**提示：**
- 链表中节点的数目范围是 [0, 5000]
- -5000 <= Node.val <= 5000

**进阶：** 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

## 思路讲解

反转链表是最基础也是最重要的链表操作之一，有多种实现方式。

### 方法一：迭代（推荐）

**核心思路：**
遍历链表，逐个改变节点的 next 指针方向。

**关键点：**
- 需要三个指针：prev（前一个节点）、curr（当前节点）、next（下一个节点）
- 在改变 curr->next 之前，必须先保存 curr->next，否则会丢失后续节点的引用

**步骤：**
1. 初始化 prev = nullptr，curr = head
2. 遍历链表：
   - 保存 next = curr->next
   - 反转当前节点：curr->next = prev
   - 移动指针：prev = curr，curr = next
3. 返回 prev（新的头节点）

### 方法二：递归

**核心思路：**
递归到链表末尾，然后在回溯过程中反转指针。

**关键理解：**
- 递归函数返回的是反转后的新头节点（原链表的尾节点）
- 在回溯时，让下一个节点指向当前节点：`head->next->next = head`
- 断开当前节点的原有指向：`head->next = nullptr`

**递归过程示例（以 1->2->3->null 为例）：**
1. 递归到节点 3，返回节点 3 作为新头
2. 回溯到节点 2：让 3->next = 2，断开 2->next
3. 回溯到节点 1：让 2->next = 1，断开 1->next
4. 最终返回节点 3

### 方法三：头插法

使用虚拟头节点，依次将原链表的节点插入到新链表的头部。

## 面试时的快速口述讲解

这道题要求反转单链表，将链表的指针方向全部反转。

**数据结构**：使用三个指针 prev、curr、next 来完成反转。

**实现方式（迭代法）**：
1. prev 指向 nullptr，curr 指向 head
2. 遍历链表，对每个节点：
   - 先保存下一个节点 next = curr->next
   - 反转当前节点的指针 curr->next = prev
   - 移动 prev 和 curr 指针向后推进
3. 最后返回 prev，它指向原链表的最后一个节点（新链表的头节点）

**时间复杂度**：O(n)，需要遍历整个链表一次。

**空间复杂度**：O(1)，只使用了常数个指针。递归方法的空间复杂度为 O(n)，因为递归调用栈的深度为 n。

## 代码实现

### 方法一：迭代（推荐）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // prev 指向当前节点的前一个节点（反转后的下一个节点）
        ListNode* prev = nullptr;
        // curr 指向当前正在处理的节点
        ListNode* curr = head;
        
        // 遍历链表
        while (curr != nullptr) {
            // 1. 保存下一个节点（必须先保存，否则反转后会丢失）
            ListNode* next = curr->next;
            
            // 2. 反转当前节点的指针
            curr->next = prev;
            
            // 3. 移动 prev 和 curr 指针
            prev = curr;
            curr = next;
        }
        
        // prev 指向原链表的最后一个节点，即新链表的头节点
        return prev;
    }
};
```

**图解过程（以 1->2->3->null 为例）：**
```
初始：prev = null, curr = 1
      null  1 -> 2 -> 3 -> null
      ↑     ↑
     prev  curr

第1步：保存 next = 2, 反转 1->next = null, 移动指针
      null <- 1  2 -> 3 -> null
              ↑  ↑
            prev curr

第2步：保存 next = 3, 反转 2->next = 1, 移动指针
      null <- 1 <- 2  3 -> null
                   ↑  ↑
                 prev curr

第3步：保存 next = null, 反转 3->next = 2, 移动指针
      null <- 1 <- 2 <- 3  null
                        ↑   ↑
                      prev curr

结束：curr = null，返回 prev (节点 3)
```

### 方法二：递归

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 递归终止条件：空链表或只有一个节点
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        
        // 递归反转后续链表，newHead 是反转后的新头节点
        ListNode* newHead = reverseList(head->next);
        
        // 反转当前节点：让下一个节点指向当前节点
        // head->next 是下一个节点，让它的 next 指向 head
        head->next->next = head;
        
        // 断开当前节点的原有指向（避免形成环）
        head->next = nullptr;
        
        // 返回新的头节点（在整个递归过程中保持不变）
        return newHead;
    }
};
```

**递归过程图解（以 1->2->3->null 为例）：**
```
调用 reverseList(1):
  调用 reverseList(2):
    调用 reverseList(3):
      返回 3 (终止条件)
    
    在 reverseList(2) 中：
      newHead = 3
      2->next->next = 2  即  3->next = 2
      2->next = null
      返回 3
      此时：null <- 2 <- 3
    
  在 reverseList(1) 中：
    newHead = 3
    1->next->next = 1  即  2->next = 1
    1->next = null
    返回 3
    最终：null <- 1 <- 2 <- 3
```

**代码说明：**
1. **迭代法**：
   - 时间复杂度：O(n)，遍历一次链表
   - 空间复杂度：O(1)，只使用三个指针
   - 优点：空间效率高，逻辑清晰，面试推荐

2. **递归法**：
   - 时间复杂度：O(n)，每个节点访问一次
   - 空间复杂度：O(n)，递归调用栈深度为 n
   - 优点：代码简洁，思路优雅
   - 注意：需要理解递归的回溯过程


---

## 相关笔记
<!-- 自动生成 -->

- [删除链表的倒数第N个结点](notes/LeetcodeHot100/删除链表的倒数第N个结点.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/删除链表的倒数第N个结点.md
- [两两交换链表中的节点](notes/LeetcodeHot100/两两交换链表中的节点.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/两两交换链表中的节点.md
- [合并两个有序链表](notes/LeetcodeHot100/合并两个有序链表.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/合并两个有序链表.md
- [随机链表的复制](notes/LeetcodeHot100/随机链表的复制.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/随机链表的复制.md
- [二叉树展开为链表](notes/LeetcodeHot100/二叉树展开为链表.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树展开为链表.md

