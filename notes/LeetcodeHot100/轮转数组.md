---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/轮转数组.md
related_outlines: []
---
# 轮转数组

## 题目描述

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1：**
```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2：**
```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

**提示：**
- 1 <= nums.length <= 10^5
- -2^31 <= nums[i] <= 2^31 - 1
- 0 <= k <= 10^5

**进阶：**
- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的原地算法解决这个问题吗？

## 思路讲解

这道题有多种解法，从简单到优雅。

### 方法一：使用额外数组

最直观的方法是创建新数组，将每个元素放到正确的位置。

**算法：**
- 新位置 = (原位置 + k) % n

时间 O(n)，空间 O(n)。

### 方法二：多次反转（最优解）

**核心思想：**
通过三次反转来实现轮转，这是最优雅的 O(1) 空间解法。

**观察：**
```
原数组：[1,2,3,4,5,6,7], k=3
目标：  [5,6,7,1,2,3,4]

分析：后3个元素移到前面，前4个元素移到后面
```

**三次反转法：**
1. 反转整个数组：[7,6,5,4,3,2,1]
2. 反转前 k 个元素：[5,6,7,4,3,2,1]
3. 反转后 n-k 个元素：[5,6,7,1,2,3,4]

**为什么可行？**
- 第一次反转：所有元素位置颠倒
- 第二次反转前 k 个：将应该在前面的元素调整到正确顺序
- 第三次反转后 n-k 个：将应该在后面的元素调整到正确顺序

**注意：k 可能大于 n，需要取模：`k = k % n`**

### 方法三：环状替换

使用一个变量跟踪每个元素应该去的位置，像走环一样替换。

时间 O(n)，空间 O(1)，但实现较复杂。

## 面试时的快速口述讲解

这道题要将数组向右轮转 k 个位置。

**数据结构**：原地操作，不需要额外数据结构。

**实现方式（三次反转法）**：
1. 先将 k 对数组长度取模，处理 k > n 的情况
2. 反转整个数组
3. 反转前 k 个元素
4. 反转后 n-k 个元素

**关键点**：三次反转巧妙地实现了元素的轮转，避免使用额外空间。

**时间复杂度**：O(n)，需要遍历数组三次。

**空间复杂度**：O(1)，原地操作。

## 代码实现

### 方法一：使用额外数组

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;  // 处理 k > n 的情况
        
        vector<int> temp(n);
        
        // 将每个元素放到新位置
        for (int i = 0; i < n; i++) {
            temp[(i + k) % n] = nums[i];
        }
        
        // 复制回原数组
        nums = temp;
    }
};
```

### 方法二：三次反转（推荐）

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;  // 处理 k > n 的情况
        
        // 三次反转
        reverse(nums.begin(), nums.end());           // 反转整个数组
        reverse(nums.begin(), nums.begin() + k);     // 反转前 k 个
        reverse(nums.begin() + k, nums.end());       // 反转后 n-k 个
    }
};
```

**手动实现 reverse：**
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        
        reverseArray(nums, 0, n - 1);      // 反转整个数组
        reverseArray(nums, 0, k - 1);      // 反转前 k 个
        reverseArray(nums, k, n - 1);      // 反转后 n-k 个
    }
    
private:
    void reverseArray(vector<int>& nums, int left, int right) {
        while (left < right) {
            swap(nums[left], nums[right]);
            left++;
            right--;
        }
    }
};
```

**代码说明：**
1. 先对 k 取模，避免不必要的旋转（k=n 相当于不旋转）
2. 三次反转：
   - 反转整个数组
   - 反转前 k 个元素（新的前半部分）
   - 反转后 n-k 个元素（新的后半部分）
3. 每次反转使用双指针交换元素

**示例演示：**
```
nums = [1,2,3,4,5,6,7], k = 3

第一步：反转整个数组
[7,6,5,4,3,2,1]

第二步：反转前3个元素
[5,6,7,4,3,2,1]

第三步：反转后4个元素
[5,6,7,1,2,3,4]

完成！
```

### 方法三：环状替换

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        
        int count = 0;  // 已经移动的元素个数
        
        for (int start = 0; count < n; start++) {
            int current = start;
            int prev = nums[start];
            
            do {
                int next = (current + k) % n;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            } while (start != current);
        }
    }
};
```

这个方法通过环状替换实现，每个元素直接移动到目标位置。

**复杂度分析：**

| 方法     | 时间复杂度 | 空间复杂度 | 难度 |
| -------- | ---------- | ---------- | ---- |
| 额外数组 | O(n)       | O(n)       | 简单 |
| 三次反转 | O(n)       | O(1)       | 中等 |
| 环状替换 | O(n)       | O(1)       | 较难 |

**易错点：**
1. **必须取模**：`k = k % n`，否则 k > n 时会出错
2. 三次反转的顺序不能错
3. 反转的边界要正确：
   - 前 k 个：`[0, k-1]`
   - 后 n-k 个：`[k, n-1]`
4. 特殊情况：k=0 或 k=n 时数组不变

**扩展：向左轮转怎么做？**

向左轮转 k 个位置 = 向右轮转 n-k 个位置

```cpp
void rotateLeft(vector<int>& nums, int k) {
    int n = nums.size();
    rotate(nums, n - k % n);
}
```

或者三次反转的顺序改变：
```cpp
void rotateLeft(vector<int>& nums, int k) {
    int n = nums.size();
    k = k % n;
    
    reverse(nums.begin(), nums.begin() + k);   // 反转前 k 个
    reverse(nums.begin() + k, nums.end());     // 反转后 n-k 个
    reverse(nums.begin(), nums.end());         // 反转整个数组
}
```


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

