---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/最小覆盖子串.md
related_outlines: []
---
# 最小覆盖子串

## 题目描述

给你一个字符串 `s`、一个字符串 `t`。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""`。

**注意：**
- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**
```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**
```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3：**
```
输入：s = "a", t = "aa"
输出：""
解释：t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。
```

**提示：**
- m == s.length
- n == t.length
- 1 <= m, n <= 10^5
- s 和 t 由英文字母组成

## 思路讲解

这是滑动窗口的经典困难题，需要动态调整窗口大小来找到最小覆盖子串。

### 滑动窗口（双指针）

**核心思想：**
1. 使用双指针维护一个滑动窗口
2. 右指针扩展窗口，直到包含 t 的所有字符
3. 左指针收缩窗口，直到不再包含 t 的所有字符
4. 在收缩过程中记录最小窗口

**算法步骤：**
1. 使用哈希表 `need` 记录 t 中每个字符需要的数量
2. 使用哈希表 `window` 记录当前窗口中每个字符的数量
3. 使用 `valid` 记录窗口中已经满足需求的字符种类数
4. 移动右指针扩展窗口：
   - 将右指针字符加入窗口
   - 更新 `window` 和 `valid`
   - 当 `valid == need.size()` 时，窗口包含所有需要的字符
5. 移动左指针收缩窗口：
   - 在收缩前记录当前窗口（可能是答案）
   - 将左指针字符移出窗口
   - 更新 `window` 和 `valid`
6. 返回最小窗口

**关键点：**
- `valid` 表示窗口中满足需求的字符种类数（不是字符总数）
- 当某个字符的数量达到需求时，`valid++`
- 当某个字符的数量低于需求时，`valid--`

**示例演示：**
```
s = "ADOBECODEBANC", t = "ABC"
need = {A:1, B:1, C:1}

right=0, window={A:1}, valid=1
right=1, window={A:1,D:1}, valid=1
right=2, window={A:1,D:1,O:1}, valid=1
right=3, window={A:1,D:1,O:1,B:1}, valid=2
right=4, window={A:1,D:1,O:1,B:1,E:1}, valid=2
right=5, window={A:1,D:1,O:1,B:1,E:1,C:1}, valid=3 ✓找到

收缩窗口：
left=0, 移除A, valid=2, 窗口不再有效
right=6, window={D:1,O:1,B:1,E:1,C:1,O:2}, valid=2
...继续扩展和收缩...

最终找到: "BANC"
```

## 面试时的快速口述讲解

这道题要找 s 中包含 t 所有字符的最小子串。

**数据结构**：滑动窗口（双指针） + 两个哈希表（need 和 window）。

**实现方式**：
1. 用 need 记录 t 中每个字符需要的数量
2. 用 window 记录当前窗口中字符的数量
3. 右指针不断扩展窗口，直到窗口包含 t 的所有字符
4. 左指针收缩窗口，在保持有效的前提下尽量缩小窗口
5. 在收缩过程中更新最小窗口

**关键点**：
- 用 valid 记录窗口中满足需求的字符种类数
- 当 valid 等于 t 中不同字符数时，窗口有效
- 收缩窗口时要先记录结果再移除左边字符

**时间复杂度**：O(m + n)，其中 m 是 s 长度，n 是 t 长度，每个字符最多被访问两次。

**空间复杂度**：O(k)，k 是字符集大小（最多 128 个 ASCII 字符）。

## 代码实现

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        // 记录 t 中字符的需求
        unordered_map<char, int> need, window;
        for (char c : t) {
            need[c]++;
        }
        
        int left = 0, right = 0;
        int valid = 0;  // 窗口中满足需求的字符种类数
        
        // 记录最小覆盖子串的起始位置和长度
        int start = 0, minLen = INT_MAX;
        
        while (right < s.length()) {
            // 扩展窗口：将右边字符加入窗口
            char c = s[right];
            right++;
            
            // 更新窗口数据
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) {
                    valid++;
                }
            }
            
            // 判断是否需要收缩窗口
            while (valid == need.size()) {
                // 更新最小覆盖子串
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }
                
                // 收缩窗口：将左边字符移出窗口
                char d = s[left];
                left++;
                
                // 更新窗口数据
                if (need.count(d)) {
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--;
                }
            }
        }
        
        // 返回最小覆盖子串
        return minLen == INT_MAX ? "" : s.substr(start, minLen);
    }
};
```

**代码说明：**
1. 初始化 `need` 记录 t 中每个字符的需求量
2. 初始化双指针 `left` 和 `right`，`valid` 记录满足条件的字符数
3. 右指针扩展窗口：
   - 将 `s[right]` 加入窗口
   - 如果是需要的字符，更新 `window` 和 `valid`
4. 当窗口包含所有需要的字符时（`valid == need.size()`）：
   - 记录当前窗口（可能是答案）
   - 收缩左边界，移除 `s[left]`
   - 更新 `window` 和 `valid`
5. 返回最小窗口

**滑动窗口框架：**
```cpp
// 滑动窗口算法框架
void slidingWindow(string s) {
    unordered_map<char, int> window;
    
    int left = 0, right = 0;
    while (right < s.size()) {
        // 扩大窗口
        char c = s[right];
        right++;
        // ... 更新窗口数据
        
        // 判断是否需要收缩
        while (window needs shrink) {
            // 缩小窗口
            char d = s[left];
            left++;
            // ... 更新窗口数据
        }
    }
}
```

**优化版本（使用数组代替哈希表）：**
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> need(128, 0);
        int count = 0;  // t 中字符的总数
        
        // 统计 t 中字符
        for (char c : t) {
            if (need[c] == 0) count++;
            need[c]++;
        }
        
        vector<int> window(128, 0);
        int left = 0, right = 0;
        int valid = 0;  // 满足需求的字符种类数
        int start = 0, minLen = INT_MAX;
        
        while (right < s.length()) {
            char c = s[right++];
            
            if (need[c] > 0) {
                window[c]++;
                if (window[c] == need[c]) {
                    valid++;
                }
            }
            
            while (valid == count) {
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }
                
                char d = s[left++];
                if (need[d] > 0) {
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--;
                }
            }
        }
        
        return minLen == INT_MAX ? "" : s.substr(start, minLen);
    }
};
```

**复杂度分析：**
- 时间复杂度：O(m + n)
  - 统计 t：O(n)
  - 双指针遍历 s：每个字符最多被访问两次，O(m)
- 空间复杂度：O(k)，k 为字符集大小（128 或 26）

**易错点：**
1. `valid` 记录的是字符种类数，不是字符总数
2. 更新最小长度时，窗口长度是 `right - left`（right 已经 +1）
3. 判断 `valid == need.size()` 时才收缩窗口
4. 收缩时要先记录结果，再移除左边字符
5. 注意 `substr` 的第二个参数是长度，不是结束位置


---

## 相关笔记
<!-- 自动生成 -->

- [无重复字符的最长子串](notes/LeetcodeHot100/无重复字符的最长子串.md) - 相似度: 39% | 标签: LeetcodeHot100, LeetcodeHot100/无重复字符的最长子串.md

