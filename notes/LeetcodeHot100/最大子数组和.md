---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/最大子数组和.md
related_outlines: []
---
# 最大子数组和

## 题目描述

给你一个整数数组 `nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

**示例 1：**
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**示例 2：**
```
输入：nums = [1]
输出：1
```

**示例 3：**
```
输入：nums = [5,4,-1,7,8]
输出：23
```

**提示：**
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4

**进阶**：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

## 思路讲解

这是一道经典的动态规划问题，也被称为**最大子段和问题**。

### 方法一：动态规划（Kadane算法）

**核心思想：**
对于位置 i，我们要决定：是将 nums[i] 加入之前的子数组，还是从 nums[i] 重新开始。

**状态定义：**
- `dp[i]` 表示以 nums[i] 结尾的最大子数组和

**状态转移方程：**
```
dp[i] = max(dp[i-1] + nums[i], nums[i])
```

**为什么这样是对的？**
- 如果 `dp[i-1] > 0`，那么加上 nums[i] 会让和更大
- 如果 `dp[i-1] <= 0`，那么不如从 nums[i] 重新开始

**算法步骤：**
1. 初始化 dp[0] = nums[0]
2. 遍历数组，对每个位置计算 dp[i]
3. 维护最大值

**空间优化：**
由于 dp[i] 只依赖 dp[i-1]，可以用一个变量代替数组。

**示例演示：**
```
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]

i=0, dp[0]=-2, maxSum=-2
i=1, dp[1]=max(-2+1, 1)=1, maxSum=1
i=2, dp[2]=max(1-3, -3)=-2, maxSum=1
i=3, dp[3]=max(-2+4, 4)=4, maxSum=4
i=4, dp[4]=max(4-1, -1)=3, maxSum=4
i=5, dp[5]=max(3+2, 2)=5, maxSum=5
i=6, dp[6]=max(5+1, 1)=6, maxSum=6
i=7, dp[7]=max(6-5, -5)=1, maxSum=6
i=8, dp[8]=max(1+4, 4)=5, maxSum=6

最大子数组和: 6
```

### 方法二：分治法

将数组分为左右两部分，最大子数组和可能在：
1. 左半部分
2. 右半部分
3. 跨越中点

时间复杂度 O(n log n)，不如动态规划优秀。

## 面试时的快速口述讲解

这道题要找连续子数组的最大和，是经典的动态规划问题。

**数据结构**：不需要额外数据结构，只需要一个变量维护当前子数组和。

**实现方式**：
1. 维护两个变量：当前子数组和 currentSum 和最大和 maxSum
2. 遍历数组，对每个元素：
   - 判断是加入当前子数组，还是从当前元素重新开始
   - 规则：如果 currentSum > 0 就加上当前元素，否则重新开始
   - 更新最大和
3. 返回最大和

**关键点**：当当前和变成负数时，不如舍弃前面的部分重新开始。这就是 Kadane 算法的核心思想。

**时间复杂度**：O(n)，只需遍历一次数组。

**空间复杂度**：O(1)，只使用常数额外空间。

## 代码实现

### 方法一：动态规划（空间优化）

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSum = nums[0];      // 全局最大和
        int currentSum = nums[0];  // 以当前位置结尾的最大和
        
        for (int i = 1; i < nums.size(); i++) {
            // 决定是加入当前子数组，还是从当前元素重新开始
            currentSum = max(currentSum + nums[i], nums[i]);
            
            // 更新全局最大和
            maxSum = max(maxSum, currentSum);
        }
        
        return maxSum;
    }
};
```

**代码说明：**
1. `currentSum` 表示以当前位置结尾的最大子数组和
2. 对每个位置，判断是否要加入之前的子数组：
   - 如果 `currentSum + nums[i] > nums[i]`，说明之前的和是正的，应该加上
   - 否则从当前元素重新开始
3. 每次更新全局最大值
4. 返回最大和

**更直观的写法：**
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSum = nums[0];
        int currentSum = nums[0];
        
        for (int i = 1; i < nums.size(); i++) {
            // 如果当前和是正的，就加上当前元素；否则重新开始
            if (currentSum > 0) {
                currentSum += nums[i];
            } else {
                currentSum = nums[i];
            }
            
            maxSum = max(maxSum, currentSum);
        }
        
        return maxSum;
    }
};
```

### 方法二：完整的动态规划数组

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n);  // dp[i] 表示以 i 结尾的最大子数组和
        
        dp[0] = nums[0];
        int maxSum = dp[0];
        
        for (int i = 1; i < n; i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            maxSum = max(maxSum, dp[i]);
        }
        
        return maxSum;
    }
};
```

### 方法三：分治法

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        return maxSubArrayHelper(nums, 0, nums.size() - 1);
    }
    
private:
    int maxSubArrayHelper(vector<int>& nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        
        int mid = left + (right - left) / 2;
        
        // 左半部分最大子数组和
        int leftMax = maxSubArrayHelper(nums, left, mid);
        
        // 右半部分最大子数组和
        int rightMax = maxSubArrayHelper(nums, mid + 1, right);
        
        // 跨越中点的最大子数组和
        int crossMax = maxCrossingSum(nums, left, mid, right);
        
        return max({leftMax, rightMax, crossMax});
    }
    
    int maxCrossingSum(vector<int>& nums, int left, int mid, int right) {
        // 从中点向左的最大和
        int leftSum = INT_MIN;
        int sum = 0;
        for (int i = mid; i >= left; i--) {
            sum += nums[i];
            leftSum = max(leftSum, sum);
        }
        
        // 从中点+1向右的最大和
        int rightSum = INT_MIN;
        sum = 0;
        for (int i = mid + 1; i <= right; i++) {
            sum += nums[i];
            rightSum = max(rightSum, sum);
        }
        
        return leftSum + rightSum;
    }
};
```

**复杂度分析：**
- **动态规划**：
  - 时间复杂度：O(n)
  - 空间复杂度：O(1)（优化版）或 O(n)（数组版）
- **分治法**：
  - 时间复杂度：O(n log n)
  - 空间复杂度：O(log n)（递归栈）

**易错点：**
1. 初始化时要用 nums[0]，不能用 0（数组可能全是负数）
2. 理解状态转移：`dp[i]` 必须包含 nums[i]，这是"以 i 结尾"的含义
3. 不要混淆 currentSum（局部最优）和 maxSum（全局最优）

**扩展：如果需要返回最大子数组的起始和结束位置？**
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSum = nums[0];
        int currentSum = nums[0];
        int start = 0, end = 0, tempStart = 0;
        
        for (int i = 1; i < nums.size(); i++) {
            if (currentSum > 0) {
                currentSum += nums[i];
            } else {
                currentSum = nums[i];
                tempStart = i;  // 记录新的起始位置
            }
            
            if (currentSum > maxSum) {
                maxSum = currentSum;
                start = tempStart;
                end = i;
            }
        }
        
        // start 和 end 就是最大子数组的起止位置
        return maxSum;
    }
};
```


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

