---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/移动零.md
related_outlines: []
---
# 移动零

## 题目描述

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意，必须在不复制数组的情况下原地对数组进行操作。

**示例 1：**
```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2：**
```
输入: nums = [0]
输出: [0]
```

**提示：**
- 1 <= nums.length <= 10^4
- -2^31 <= nums[i] <= 2^31 - 1

**进阶**：你能尽量减少完成的操作次数吗？

## 思路讲解

这道题要求原地移动数组元素，将所有 0 移到末尾，同时保持非零元素的相对顺序。

### 双指针解法

使用双指针，一个指针用于遍历数组，另一个指针指向下一个非零元素应该放置的位置。

**核心思想：**
- 使用快慢指针，慢指针 `slow` 指向下一个非零元素应该放置的位置
- 快指针 `fast` 遍历整个数组
- 当 `fast` 指向非零元素时，将其与 `slow` 位置的元素交换，然后 `slow++`
- 这样可以保证 `slow` 左边都是非零元素，且相对顺序不变

**算法步骤：**
1. 初始化慢指针 `slow = 0`
2. 快指针 `fast` 遍历数组：
   - 如果 `nums[fast] != 0`，交换 `nums[slow]` 和 `nums[fast]`，然后 `slow++`
   - 如果 `nums[fast] == 0`，继续遍历
3. 遍历结束后，`slow` 之前都是非零元素，之后都是 0

**示例演示：**
```
初始: [0, 1, 0, 3, 12]
      slow=0, fast=0

fast=0, nums[0]=0, 不交换
fast=1, nums[1]=1, 交换 slow(0) 和 fast(1): [1, 0, 0, 3, 12], slow++
fast=2, nums[2]=0, 不交换
fast=3, nums[3]=3, 交换 slow(1) 和 fast(3): [1, 3, 0, 0, 12], slow++
fast=4, nums[4]=12, 交换 slow(2) 和 fast(4): [1, 3, 12, 0, 0], slow++

结果: [1, 3, 12, 0, 0]
```

### 方法二：两次遍历
另一种思路是先把所有非零元素移到前面，然后将剩余位置填充 0。但这种方法需要更多操作。

## 面试时的快速口述讲解

这道题要求原地移动所有零到数组末尾，保持非零元素的相对顺序。

**数据结构**：原地操作，不需要额外数据结构。

**实现方式**：使用双指针
- 慢指针 `slow` 指向下一个非零元素应该放置的位置
- 快指针 `fast` 遍历整个数组
- 当快指针遇到非零元素时，将其与慢指针位置交换，然后慢指针右移
- 这样慢指针左边都是非零元素，右边都是零

**关键点**：交换操作保证了非零元素的相对顺序不变。

**时间复杂度**：O(n)，只需要遍历一次数组。

**空间复杂度**：O(1)，只使用常数额外空间。

## 代码实现

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;  // 慢指针，指向下一个非零元素应该放置的位置
        
        // 快指针遍历数组
        for (int fast = 0; fast < nums.size(); fast++) {
            // 如果快指针指向非零元素
            if (nums[fast] != 0) {
                // 交换快慢指针的元素
                swap(nums[slow], nums[fast]);
                slow++;
            }
        }
    }
};
```

**代码说明：**
1. `slow` 指针初始化为 0，指向下一个非零元素应该放的位置
2. `fast` 指针遍历整个数组：
   - 如果 `nums[fast]` 是非零元素，将其与 `nums[slow]` 交换
   - 然后 `slow++`，为下一个非零元素腾出位置
3. 循环结束后，`slow` 之前都是非零元素，之后都是 0

**为什么相对顺序不变？**
- 当 `slow == fast` 时，交换元素本身，相对顺序不变
- 当 `slow < fast` 时，slow 位置一定是 0（或者在第一次交换前），将 fast 位置的非零元素前移，不会改变非零元素之间的相对顺序

**优化：避免不必要的交换**
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        
        for (int fast = 0; fast < nums.size(); fast++) {
            if (nums[fast] != 0) {
                // 只在 slow != fast 时才交换，减少不必要的操作
                if (slow != fast) {
                    swap(nums[slow], nums[fast]);
                }
                slow++;
            }
        }
    }
};
```

**方法二：两次遍历**
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        
        // 第一次遍历：将所有非零元素移到前面
        for (int fast = 0; fast < nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow++] = nums[fast];
            }
        }
        
        // 第二次遍历：将剩余位置填充 0
        for (int i = slow; i < nums.size(); i++) {
            nums[i] = 0;
        }
    }
};
```

这种方法虽然也是 O(n)，但需要遍历两次，操作次数更多。


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

