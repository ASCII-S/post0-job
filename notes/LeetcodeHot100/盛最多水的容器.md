---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/盛最多水的容器.md
related_outlines: []
---
# 盛最多水的容器

## 题目描述

给定一个长度为 `n` 的整数数组 `height`。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])`。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明**：你不能倾斜容器。

**示例 1：**
```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。
在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**
```
输入：height = [1,1]
输出：1
```

**提示：**
- n == height.length
- 2 <= n <= 10^5
- 0 <= height[i] <= 10^4

## 思路讲解

容器的盛水量由两条线的距离和较短的那条线决定：`面积 = (右边界 - 左边界) × min(左高度, 右高度)`

### 暴力解法
枚举所有可能的两条线组合，计算面积，取最大值。时间复杂度 O(n²)。

### 双指针解法（最优解）

**核心思想：**
- 从两端向中间收缩，每次移动较短的那条边
- 这样可以在 O(n) 时间内找到最大面积

**为什么这样是正确的？**

设左指针 `left`，右指针 `right`。
- 当前面积 = `(right - left) × min(height[left], height[right])`
- 假设 `height[left] < height[right]`

如果我们移动右指针：
- 宽度减小：`right - left` 变小
- 高度不会增加：新的高度仍然受 `height[left]` 限制（因为 `height[left]` 更短）
- 所以面积只会变小或不变

如果我们移动左指针：
- 宽度减小：`right - left` 变小
- 但高度可能增加：新的 `height[left]` 可能更大，有机会得到更大面积

**结论：每次都移动较短的边，才有可能找到更大的面积。**

**算法步骤：**
1. 初始化左指针 `left = 0`，右指针 `right = n - 1`
2. 初始化最大面积 `maxArea = 0`
3. 当 `left < right` 时：
   - 计算当前面积：`area = (right - left) × min(height[left], height[right])`
   - 更新最大面积
   - 如果 `height[left] < height[right]`，移动左指针 `left++`
   - 否则移动右指针 `right--`
4. 返回最大面积

**示例演示：**
```
height = [1,8,6,2,5,4,8,3,7]

初始: left=0(高度1), right=8(高度7), 面积=(8-0)*min(1,7)=8
移动left(1更小): left=1(高度8), right=8(高度7), 面积=(8-1)*min(8,7)=49
移动right(7更小): left=1(高度8), right=7(高度3), 面积=(7-1)*min(8,3)=18
...继续移动...

最大面积: 49
```

## 面试时的快速口述讲解

这道题要找两条线构成的容器能盛最多的水，面积等于两线距离乘以较短线的高度。

**数据结构**：不需要额外数据结构，只用两个指针。

**实现方式**：双指针从两端向中间收缩
1. 左右指针分别指向数组两端
2. 计算当前面积，更新最大值
3. 移动较短的那条边的指针（因为只有增加短边的高度才可能增加面积）
4. 重复直到两指针相遇

**关键点**：每次移动较短的边。因为移动较长的边，宽度减小，高度受限于短边，面积只会变小。

**时间复杂度**：O(n)，双指针只遍历一次数组。

**空间复杂度**：O(1)，只使用常数额外空间。

## 代码实现

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int maxArea = 0;
        
        while (left < right) {
            // 计算当前面积：宽度 × 较短边的高度
            int width = right - left;
            int currentHeight = min(height[left], height[right]);
            int currentArea = width * currentHeight;
            
            // 更新最大面积
            maxArea = max(maxArea, currentArea);
            
            // 移动较短的边
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
};
```

**代码说明：**
1. 初始化左右指针分别指向数组两端
2. 在 `left < right` 时循环：
   - 计算当前宽度和高度（取两边较小值）
   - 计算当前面积并更新最大值
   - 移动较短边的指针（如果两边相等，移动哪个都可以）
3. 返回最大面积

**简化版本：**
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int maxArea = 0;
        
        while (left < right) {
            // 一行计算当前面积
            maxArea = max(maxArea, 
                         (right - left) * min(height[left], height[right]));
            
            // 移动较短的边
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
};
```

**正确性证明：**
- 假设最优解是 `(i, j)`，其中 `i < j`
- 在双指针移动过程中，一定会经过 `left <= i` 且 `right >= j` 的状态
- 从这个状态到 `(i, j)` 的过程中，我们不会错过最优解
- 因为只有移动较短边才可能找到更好的解，而我们的算法正是这样做的

**时间复杂度分析：**
- 每次循环移动一个指针
- 最多移动 n 次
- 所以时间复杂度是 O(n)


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

