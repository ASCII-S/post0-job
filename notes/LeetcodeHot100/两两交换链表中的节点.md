---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/两两交换链表中的节点.md
related_outlines: []
---
# 两两交换链表中的节点

## 题目描述

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**
```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**
```
输入：head = []
输出：[]
```

**示例 3：**
```
输入：head = [1]
输出：[1]
```

**提示：**
- 链表中节点的数目在范围 [0, 100] 内
- 0 <= Node.val <= 100

## 思路讲解

这道题要求两两交换相邻节点，是一道经典的链表操作题，需要仔细处理指针关系。

### 方法一：迭代（推荐）

**核心思路：**
使用虚拟头节点，每次处理一对节点，交换它们的位置。

**关键难点：**
- 交换两个节点需要修改多个指针
- 需要记住前一个节点，用于连接交换后的节点
- 要注意指针修改的顺序，避免丢失节点引用

**交换步骤（交换节点1和节点2）：**
```
交换前：
prev -> 1 -> 2 -> 3 -> 4

需要修改的指针：
1. prev->next 指向 2
2. 1->next 指向 3
3. 2->next 指向 1

交换后：
prev -> 2 -> 1 -> 3 -> 4
```

**算法步骤：**
1. 创建虚拟头节点 dummy
2. 用 prev 指针记录前一对节点的后一个节点
3. 检查是否还有两个节点可以交换
4. 交换当前这一对节点：
   - 记录两个节点：first, second
   - 修改指针：prev->next、first->next、second->next
5. 更新 prev 为交换后的后一个节点（即 first）
6. 重复直到没有成对的节点

### 方法二：递归

**核心思路：**
递归地交换链表的前两个节点，然后递归处理剩余部分。

**递归定义：**
- 交换当前节点和下一个节点
- 当前节点的 next 指向递归处理后的结果
- 返回交换后的新头节点（原来的第二个节点）

**递归终止条件：**
- 链表为空或只有一个节点，无需交换

## 面试时的快速口述讲解

这道题要求两两交换链表中的相邻节点，注意必须交换节点本身，不能只交换值。

**数据结构**：使用虚拟头节点，用一个指针记录前一对节点的位置。

**实现方式（迭代法）**：
1. 创建虚拟头节点 dummy，初始化 prev = dummy
2. 当还有至少两个节点可以交换时（prev->next 和 prev->next->next 都存在）：
   - 记录两个待交换节点 first 和 second
   - 修改指针完成交换：
     - prev->next = second
     - first->next = second->next
     - second->next = first
   - 更新 prev = first（为下一次交换做准备）
3. 返回 dummy->next

**时间复杂度**：O(n)，需要遍历整个链表一次。

**空间复杂度**：O(1)，只使用了常数个指针。递归方法的空间复杂度为 O(n)，因为递归调用栈。

## 代码实现

### 方法一：迭代（推荐）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 创建虚拟头节点
        ListNode* dummy = new ListNode(0, head);
        
        // prev 指向当前这对节点的前一个节点
        ListNode* prev = dummy;
        
        // 当还有至少两个节点可以交换时
        while (prev->next != nullptr && prev->next->next != nullptr) {
            // 记录两个待交换的节点
            ListNode* first = prev->next;
            ListNode* second = prev->next->next;
            
            // 交换节点（注意修改顺序，避免丢失引用）
            // 1. prev 指向 second（跳过 first）
            prev->next = second;
            // 2. first 指向 second 的下一个节点
            first->next = second->next;
            // 3. second 指向 first（完成交换）
            second->next = first;
            
            // 移动 prev 到下一对节点的前一个位置
            // 交换后，first 在 second 后面，所以 prev = first
            prev = first;
        }
        
        return dummy->next;
    }
};
```

**代码说明：**

**指针修改顺序很重要！**
```
原始：prev -> 1 -> 2 -> 3 -> 4
           first second

步骤1：prev->next = second
      prev ------> 2 -> 3 -> 4
                   ↑
      1 ---------> |
      first

步骤2：first->next = second->next
      prev ------> 2 -> 3 -> 4
                   ↑
      1 ---------->|-----> 3 -> 4
      first

步骤3：second->next = first
      prev ------> 2 -> 1 -> 3 -> 4
                   second first

结果：prev -> 2 -> 1 -> 3 -> 4
```

**图解完整过程（[1,2,3,4]）：**
```
初始：
dummy -> 1 -> 2 -> 3 -> 4
↑
prev

第一次交换：
交换前：dummy -> 1 -> 2 -> 3 -> 4
       ↑        ↑    ↑
       prev   first second

交换后：dummy -> 2 -> 1 -> 3 -> 4
                     ↑
                    prev

第二次交换：
交换前：dummy -> 2 -> 1 -> 3 -> 4
                          ↑    ↑    ↑
                        prev first second

交换后：dummy -> 2 -> 1 -> 4 -> 3
                               ↑
                              prev

没有更多成对节点，结束
结果：2 -> 1 -> 4 -> 3
```

### 方法二：递归

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 递归终止条件：空链表或只有一个节点
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        
        // 记录两个节点
        ListNode* first = head;
        ListNode* second = head->next;
        
        // 递归交换后面的节点
        first->next = swapPairs(second->next);
        
        // 交换当前的两个节点
        second->next = first;
        
        // 返回新的头节点（原来的第二个节点）
        return second;
    }
};
```

**递归过程图解（[1,2,3,4]）：**
```
swapPairs([1,2,3,4])
  first = 1, second = 2
  
  1->next = swapPairs([3,4])
    first = 3, second = 4
    
    3->next = swapPairs([]) = null
    
    4->next = 3
    返回 4
    
    现在：4 -> 3 -> null
  
  1->next = 4
  2->next = 1
  返回 2
  
最终：2 -> 1 -> 4 -> 3 -> null
```

**递归调用栈：**
```
swapPairs([1,2,3,4])
  ├─ swapPairs([3,4])
  │   └─ swapPairs([]) = null
  │   返回：4 -> 3
  └─ 1->next = 4->3
     2->next = 1
     返回：2 -> 1 -> 4 -> 3
```

**更简洁的递归写法：**
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (!head || !head->next) return head;
        
        ListNode* newHead = head->next;
        head->next = swapPairs(newHead->next);
        newHead->next = head;
        
        return newHead;
    }
};
```

**复杂度对比：**
- 方法一（迭代）：时间 O(n)，空间 O(1)，推荐
- 方法二（递归）：时间 O(n)，空间 O(n)，代码简洁

**常见错误：**
1. 指针修改顺序错误，导致丢失节点引用
2. 忘记处理奇数个节点的情况
3. 没有使用虚拟头节点，需要特殊处理头节点

**面试技巧：**
- 优先使用迭代法，空间复杂度更优
- 画图说明指针修改过程
- 强调修改指针的顺序很关键
- 可以补充递归解法作为对比


---

## 相关笔记
<!-- 自动生成 -->

- [合并两个有序链表](notes/LeetcodeHot100/合并两个有序链表.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/合并两个有序链表.md
- [反转链表](notes/LeetcodeHot100/反转链表.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/反转链表.md
- [排序链表](notes/LeetcodeHot100/排序链表.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/排序链表.md
- [K个一组翻转链表](notes/LeetcodeHot100/K个一组翻转链表.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/K个一组翻转链表.md
- [删除链表的倒数第N个结点](notes/LeetcodeHot100/删除链表的倒数第N个结点.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/删除链表的倒数第N个结点.md

