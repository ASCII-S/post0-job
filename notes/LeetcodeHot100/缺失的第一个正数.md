---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/缺失的第一个正数.md
related_outlines: []
---
# 缺失的第一个正数

## 题目描述

给你一个未排序的整数数组 `nums`，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

**示例 1：**
```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**
```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**
```
输入：nums = [7,8,9,11,12]
输出：1
```

**提示：**
- 1 <= nums.length <= 10^5
- -2^31 <= nums[i] <= 2^31 - 1

## 思路讲解

这是一道经典的困难题，关键是**原地哈希**的思想。

### 核心观察

**重要性质：**
- 对于长度为 n 的数组，答案一定在 [1, n+1] 范围内
- 如果 [1, n] 都出现了，答案就是 n+1
- 否则，答案是 [1, n] 中第一个缺失的数

**为什么答案范围是 [1, n+1]？**
- 最理想情况：数组是 [1, 2, 3, ..., n]，答案是 n+1
- 其他情况：[1, n] 中至少有一个数缺失

### 原地哈希

**核心思想：**
将数组本身作为哈希表，让每个数字出现在对应的位置上。
- 数字 1 应该在索引 0
- 数字 2 应该在索引 1
- 数字 i 应该在索引 i-1

**算法步骤：**
1. **预处理**：将所有 <= 0 或 > n 的数字标记为不可能是答案（改为 n+1）
2. **标记**：遍历数组，将 nums[i] 对应位置的数字变为负数（表示 nums[i] 出现过）
   - 如果 1 <= nums[i] <= n，将 nums[nums[i] - 1] 变为负数
3. **查找**：第一个正数的位置 + 1 就是答案
   - 如果所有数都是负数，答案是 n+1

**示例演示：**
```
nums = [3, 4, -1, 1]

步骤1：预处理，将 -1 改为 5（n+1）
nums = [3, 4, 5, 1]

步骤2：标记
i=0, nums[0]=3, 将 nums[2] 变负: [3, 4, -5, 1]
i=1, nums[1]=4, 将 nums[3] 变负: [3, 4, -5, -1]
i=2, nums[2]=-5, abs=5>4, 跳过
i=3, nums[3]=-1, abs=1, 将 nums[0] 变负: [-3, 4, -5, -1]

步骤3：查找第一个正数
nums[1]=4 是正数，答案是 1+1=2
```

### 方法二：置换法

将每个数字交换到它应该在的位置。

## 面试时的快速口述讲解

这道题要找缺失的最小正整数，要求 O(n) 时间和 O(1) 空间。

**数据结构**：原地哈希，将数组本身作为哈希表。

**实现方式**：
1. 关键观察：答案一定在 [1, n+1] 范围内
2. 将数组作为哈希表，让数字 i 出现在索引 i-1 的位置
3. 遍历数组，用正负号标记某个数字是否出现
   - 如果数字 x 出现，将 nums[x-1] 变为负数
4. 第一个仍为正数的位置 i，答案就是 i+1
5. 如果全是负数，答案是 n+1

**关键点**：
- 使用正负号标记，不需要额外空间
- 先预处理负数和超出范围的数
- 使用 abs 取绝对值来获取原始数字

**时间复杂度**：O(n)，遍历三次数组。

**空间复杂度**：O(1)，原地操作。

## 代码实现

### 方法一：原地哈希（推荐）

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        
        // 步骤1：将所有 <= 0 或 > n 的数改为 n+1
        // 因为答案一定在 [1, n+1] 范围内，这些数不可能是答案
        for (int i = 0; i < n; i++) {
            if (nums[i] <= 0 || nums[i] > n) {
                nums[i] = n + 1;
            }
        }
        
        // 步骤2：使用正负号标记数字是否出现
        // 如果数字 x 出现，将 nums[x-1] 标记为负数
        for (int i = 0; i < n; i++) {
            int num = abs(nums[i]);
            
            // 如果 num 在 [1, n] 范围内
            if (num <= n) {
                // 将 nums[num-1] 标记为负数
                // 注意要用 abs，因为可能已经被标记过了
                nums[num - 1] = -abs(nums[num - 1]);
            }
        }
        
        // 步骤3：找第一个正数的位置
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                return i + 1;  // 位置 i 对应数字 i+1
            }
        }
        
        // 如果 [1, n] 都出现了，答案是 n+1
        return n + 1;
    }
};
```

**代码说明：**
1. **预处理**：将无效数字（<= 0 或 > n）改为 n+1
2. **标记**：遍历数组，用负号标记出现过的数字
   - 取绝对值获取原始数字
   - 将对应位置标记为负数
   - 使用 `-abs()` 保证即使已经是负数也能正确标记
3. **查找**：第一个正数位置 i 对应缺失的数字 i+1

### 方法二：置换法

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        
        // 将每个数字交换到它应该在的位置
        for (int i = 0; i < n; i++) {
            // nums[i] 应该在 nums[nums[i] - 1] 位置
            // 持续交换直到当前位置正确或无法交换
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[nums[i] - 1], nums[i]);
            }
        }
        
        // 找第一个不匹配的位置
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        
        return n + 1;
    }
};
```

**置换法说明：**
- 将数字 i 交换到索引 i-1 的位置
- 交换条件：
  - `nums[i] > 0 && nums[i] <= n`：数字在有效范围内
  - `nums[nums[i] - 1] != nums[i]`：目标位置还不是这个数字
- 交换后第一个 `nums[i] != i+1` 的位置，答案就是 i+1

**示例演示（置换法）：**
```
nums = [3, 4, -1, 1]

i=0, nums[0]=3, 应该在索引2
  交换 nums[0] 和 nums[2]: [−1, 4, 3, 1]
  nums[0]=-1, 停止

i=1, nums[1]=4, 应该在索引3
  交换 nums[1] 和 nums[3]: [−1, 1, 3, 4]
  nums[1]=1, 应该在索引0
  交换 nums[1] 和 nums[0]: [1, −1, 3, 4]
  nums[1]=-1, 停止

i=2, nums[2]=3, 已在正确位置
i=3, nums[3]=4, 已在正确位置

查找：nums[1]=-1 != 2, 答案是 2
```

**复杂度分析：**
- 时间复杂度：O(n)
  - 方法一：三次遍历，每次 O(n)
  - 方法二：虽然有 while 循环，但每个元素最多被交换一次，总体 O(n)
- 空间复杂度：O(1)，原地操作

**易错点：**
1. **方法一**：
   - 标记时要用 `abs(nums[i])`，因为可能已经被标记为负数
   - 标记目标位置时也要用 `-abs(nums[num-1])`
   - 边界条件：`num <= n`
2. **方法二**：
   - while 循环条件：`nums[nums[i] - 1] != nums[i]` 防止死循环
   - 交换时要小心数组越界

**为什么这两种方法都是 O(n)？**
- 方法一：明显是三次遍历
- 方法二：虽然有嵌套循环，但每个元素最多被交换到正确位置一次，所以总交换次数不超过 n

**相关问题：**
- 找到所有数组中消失的数字
- 数组中重复的数据


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

