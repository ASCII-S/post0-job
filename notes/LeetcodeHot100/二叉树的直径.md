---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/二叉树的直径.md
related_outlines: []
---
# 二叉树的直径

## 题目描述

给你一棵二叉树的根节点 `root`，返回该树的**直径**。

二叉树的**直径**是指树中任意两个节点之间最长路径的**长度**。这条路径可能经过也可能不经过根节点。

两节点之间路径的**长度**由它们之间的边数表示。

**示例 1：**
```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**
```
输入：root = [1,2]
输出：1
```

**提示：**
- 树中节点数目在范围 [1, 10^4] 内
- -100 <= Node.val <= 100

## 思路讲解

这道题的关键是理解：**经过某个节点的最长路径 = 左子树深度 + 右子树深度**。

### 核心思想

1. **直径的本质**：任意两点间的最长路径
2. **关键观察**：这条最长路径必然会经过某个节点（作为"拐点"）
3. **对于每个节点**：经过它的最长路径 = 左子树高度 + 右子树高度

### 解题步骤

1. 使用深度优先搜索（DFS）遍历每个节点
2. 对于每个节点，计算：
   - 左子树的深度
   - 右子树的深度
   - 经过当前节点的路径长度 = 左子树深度 + 右子树深度
3. 在遍历过程中，维护全局最大值（直径）
4. 向上返回当前节点的深度：max(左子树深度, 右子树深度) + 1

### 关键点

- **路径长度 vs 节点数**：题目要求的是边数（路径长度），不是节点数
- **深度的定义**：从当前节点到叶子节点的最长路径的边数
- **递归的双重作用**：既要计算深度（向上返回），又要更新直径（全局变量）
- **遍历所有节点**：因为最长路径可能经过任何节点，需要检查所有节点作为"拐点"的情况

## 面试时的快速口述讲解

这道题要求计算二叉树的直径，即任意两个节点之间的最长路径长度。

**数据结构**：使用递归（DFS），需要一个全局变量记录最大直径。

**实现方式**：
1. 通过递归计算每个节点的深度
2. 在递归过程中，对于每个节点，计算经过它的最长路径（左子树深度 + 右子树深度）
3. 用全局变量维护所有路径中的最大值
4. 递归返回当前节点的深度（max(左深度, 右深度) + 1）供父节点使用

**关键理解**：最长路径必然经过某个节点，这个节点的左右子树深度之和就是经过它的路径长度。

**时间复杂度**：O(n)，每个节点访问一次。

**空间复杂度**：O(h)，h 是树的高度，递归调用栈的深度。

## 代码实现

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int diameter = 0;  // 全局变量，记录最大直径
        depth(root, diameter);
        return diameter;
    }
    
private:
    // 计算节点的深度，同时更新直径
    int depth(TreeNode* node, int& diameter) {
        // 空节点的深度为 0
        if (node == nullptr) {
            return 0;
        }
        
        // 递归计算左右子树的深度
        int leftDepth = depth(node->left, diameter);
        int rightDepth = depth(node->right, diameter);
        
        // 更新直径：经过当前节点的最长路径
        // 左子树深度 + 右子树深度 = 经过当前节点的路径长度
        diameter = max(diameter, leftDepth + rightDepth);
        
        // 返回当前节点的深度（供父节点计算使用）
        return max(leftDepth, rightDepth) + 1;
    }
};
```

**代码说明：**

1. **主函数 `diameterOfBinaryTree`**：
   - 初始化 `diameter` 为 0，用于记录全局最大直径
   - 调用辅助函数 `depth` 开始递归
   - 返回最终的最大直径

2. **辅助函数 `depth`**：
   - **参数**：当前节点 `node` 和直径的引用 `diameter`
   - **返回值**：当前节点的深度
   - **递归终止条件**：空节点深度为 0
   - **递归逻辑**：
     - 递归计算左右子树的深度
     - 更新全局最大直径：`diameter = max(diameter, leftDepth + rightDepth)`
     - 返回当前节点的深度：`max(leftDepth, rightDepth) + 1`

3. **关键理解**：
   - **深度**：从当前节点向下到叶子节点的最长路径的边数
   - **直径**：经过当前节点的路径长度 = 左子树深度 + 右子树深度
   - 对于示例 `[1,2,3,4,5]`：
     - 节点 2 的左子树深度为 1（到节点 4），右子树深度为 1（到节点 5）
     - 经过节点 2 的路径长度 = 1 + 1 = 2（路径：4->2->5）
     - 节点 1 的左子树深度为 2，右子树深度为 1
     - 经过节点 1 的路径长度 = 2 + 1 = 3（路径：4->2->1->3）
     - 最大直径为 3

**为什么这样做是对的？**
- 树中任意两点的最长路径必然会经过某个节点（作为"拐点"或端点）
- 通过 DFS 遍历，我们检查了每个节点作为这个"拐点"时的路径长度
- 使用全局变量记录所有情况中的最大值，就得到了树的直径


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

