---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/矩阵置零.md
related_outlines: []
---
# 矩阵置零

## 题目描述

给定一个 `m x n` 的矩阵，如果一个元素为 **0**，则将其所在行和列的所有元素都设为 **0**。请使用**原地**算法。

**示例 1：**
```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

**示例 2：**
```
输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**提示：**
- m == matrix.length
- n == matrix[0].length
- 1 <= m, n <= 200
- -2^31 <= matrix[i][j] <= 2^31 - 1

**进阶：**
- 一个直观的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常数空间的解决方案吗？

## 思路讲解

这道题的难点在于**原地修改**，不能直接将遇到的 0 所在行列置零（会影响后续判断）。

### 方法一：使用标记数组

**思路：**
使用两个数组记录哪些行和列需要置零。

1. 创建 `rows` 和 `cols` 数组
2. 第一次遍历：标记需要置零的行和列
3. 第二次遍历：根据标记将对应位置置零

空间复杂度 O(m + n)。

### 方法二：使用矩阵第一行和第一列作为标记（O(1) 空间）

**核心思想：**
利用矩阵的第一行和第一列作为标记空间。

**难点：**
第一行和第一列本身也可能有 0，需要单独记录。

**算法步骤：**
1. **特殊处理**：用两个变量记录第一行和第一列是否有 0
2. **标记**：遍历矩阵（从第二行第二列开始），如果 `matrix[i][j] == 0`：
   - 将 `matrix[i][0]` 置为 0（标记第 i 行需要置零）
   - 将 `matrix[0][j]` 置为 0（标记第 j 列需要置零）
3. **置零**：根据第一行和第一列的标记，将对应位置置零
4. **处理第一行和第一列**：根据步骤1的标记处理

**示例演示：**
```
原矩阵：
1  1  1
1  0  1
1  1  1

步骤1：检查第一行第一列
firstRow = false（第一行无0）
firstCol = false（第一列无0）

步骤2：标记（从 matrix[1][1] 开始）
matrix[1][1] = 0
→ matrix[1][0] = 0（标记第1行）
→ matrix[0][1] = 0（标记第1列）

矩阵变为：
1  0  1
0  0  1
1  1  1

步骤3：根据标记置零
第1行：matrix[1][0]=0 → 第1行全部置零
第1列：matrix[0][1]=0 → 第1列全部置零

最终：
1  0  1
0  0  0
1  0  1
```

## 面试时的快速口述讲解

这道题要将矩阵中为 0 的元素所在行和列全部置零，要求原地操作。

**数据结构**：使用矩阵的第一行和第一列作为标记空间，O(1) 额外空间。

**实现方式**：
1. 用两个布尔变量记录第一行和第一列本身是否需要置零
2. 遍历矩阵（除第一行第一列），遇到 0 就在第一行和第一列对应位置标记
3. 根据第一行和第一列的标记，将对应位置置零
4. 最后根据步骤1的标记，处理第一行和第一列

**关键点**：
- 第一行和第一列既是数据又是标记，需要特殊处理
- 置零顺序很重要：先处理中间部分，最后处理第一行和第一列

**时间复杂度**：O(m × n)，需要遍历矩阵几次。

**空间复杂度**：O(1)，只使用常数额外空间。

## 代码实现

### 方法一：使用标记数组

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        
        vector<bool> rows(m, false);  // 标记哪些行需要置零
        vector<bool> cols(n, false);  // 标记哪些列需要置零
        
        // 第一次遍历：标记
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    rows[i] = true;
                    cols[j] = true;
                }
            }
        }
        
        // 第二次遍历：置零
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (rows[i] || cols[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
};
```

### 方法二：O(1) 空间（推荐）

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        
        // 标记第一行和第一列本身是否需要置零
        bool firstRowZero = false;
        bool firstColZero = false;
        
        // 检查第一行是否有0
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                firstRowZero = true;
                break;
            }
        }
        
        // 检查第一列是否有0
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColZero = true;
                break;
            }
        }
        
        // 使用第一行和第一列作为标记
        // 从第二行第二列开始遍历
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;  // 标记第 i 行
                    matrix[0][j] = 0;  // 标记第 j 列
                }
            }
        }
        
        // 根据标记置零（从第二行第二列开始）
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        // 处理第一行
        if (firstRowZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }
        
        // 处理第一列
        if (firstColZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
};
```

**代码说明：**
1. 先记录第一行和第一列本身是否需要置零
2. 遍历矩阵（除第一行第一列），用第一行和第一列标记
3. 根据标记置零中间部分
4. 最后根据 `firstRowZero` 和 `firstColZero` 处理第一行和第一列

**简化版本（用一个变量）：**
```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        bool firstColZero = false;
        
        // 第一遍：标记
        for (int i = 0; i < m; i++) {
            // 检查第一列
            if (matrix[i][0] == 0) {
                firstColZero = true;
            }
            
            // 从第二列开始检查
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        
        // 第二遍：根据标记置零（从后向前）
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 1; j--) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            
            // 处理第一列
            if (firstColZero) {
                matrix[i][0] = 0;
            }
        }
    }
};
```

这个版本只用一个变量记录第一列，用 `matrix[0][0]` 记录第一行。

**复杂度分析：**
- 时间复杂度：O(m × n)，需要遍历矩阵 2-3 次
- 空间复杂度：
  - 方法一：O(m + n)
  - 方法二：O(1)

**易错点：**
1. 不能边遍历边置零，会影响后续判断
2. 第一行和第一列的处理顺序很重要，要最后处理
3. 标记时从第二行第二列开始（`i=1, j=1`）
4. 置零时也要从第二行第二列开始，第一行第一列单独处理

**为什么从后向前遍历（简化版本）？**
从后向前可以避免覆盖标记信息，因为我们是在处理后才置零。


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

