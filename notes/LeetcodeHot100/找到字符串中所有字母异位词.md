---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/找到字符串中所有字母异位词.md
related_outlines: []
---
# 找到字符串中所有字母异位词

## 题目描述

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的**异位词**的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词**指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1：**
```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**示例 2：**
```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示：**
- 1 <= s.length, p.length <= 3 × 10^4
- s 和 p 仅包含小写字母

## 思路讲解

这道题是典型的固定长度滑动窗口问题。

### 滑动窗口 + 字符计数

**核心思想：**
- 维护一个长度为 `p.length()` 的滑动窗口
- 比较窗口内字符的出现次数是否与 `p` 相同

**算法步骤：**
1. 统计字符串 `p` 中每个字符的出现次数
2. 使用固定大小的滑动窗口在 `s` 中移动：
   - 窗口大小固定为 `p.length()`
   - 维护窗口内字符的计数
3. 当窗口右边界到达时，检查窗口内字符计数是否与 `p` 相同
4. 如果相同，记录窗口起始位置
5. 移动窗口：移除左边字符，添加右边字符

**优化思路：**
不需要每次都比较两个计数数组，可以维护一个"有效字符数"：
- 当窗口内某个字符的计数与 `p` 中该字符计数相等时，有效字符数 +1
- 当有效字符数等于 `p` 中不同字符的数量时，说明找到了异位词

**示例演示：**
```
s = "cbaebabacd", p = "abc"
p的计数: {a:1, b:1, c:1}

窗口大小: 3

[cba]ebabacd  窗口计数{c:1,b:1,a:1} 匹配！记录索引0
c[bae]babacd  窗口计数{b:1,a:1,e:1} 不匹配
cb[aeb]abacd  窗口计数{a:1,e:1,b:1} 不匹配
cba[eba]bacd  窗口计数{e:1,b:1,a:1} 不匹配
cbae[bab]acd  窗口计数{b:2,a:1} 不匹配
cbaeb[aba]cd  窗口计数{a:2,b:1} 不匹配
cbaeba[bac]d  窗口计数{b:1,a:1,c:1} 匹配！记录索引6
cbaeab[acd]   窗口计数{a:1,c:1,d:1} 不匹配

结果: [0, 6]
```

## 面试时的快速口述讲解

这道题要找字符串 s 中所有 p 的异位词子串的起始位置。

**数据结构**：固定长度滑动窗口 + 两个计数数组（或哈希表）。

**实现方式**：
1. 先统计 p 中每个字符出现的次数
2. 在 s 上维护一个长度为 p.length() 的滑动窗口
3. 统计窗口内字符的出现次数
4. 每次窗口滑动时，比较窗口内的字符计数和 p 的字符计数
5. 如果完全相同，记录起始索引

**关键点**：固定长度滑动窗口，移除左边字符的同时添加右边字符，保持窗口大小不变。

**时间复杂度**：O(n)，其中 n 是 s 的长度，每个字符最多被访问两次。

**空间复杂度**：O(1)，只使用大小为 26 的数组（小写字母）。

## 代码实现

### 方法一：直接比较计数数组

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        int sLen = s.length(), pLen = p.length();
        
        if (sLen < pLen) return result;
        
        // 统计 p 中每个字符的出现次数
        vector<int> pCount(26, 0);
        for (char c : p) {
            pCount[c - 'a']++;
        }
        
        // 滑动窗口的字符计数
        vector<int> windowCount(26, 0);
        
        // 初始化窗口
        for (int i = 0; i < pLen; i++) {
            windowCount[s[i] - 'a']++;
        }
        
        // 检查第一个窗口
        if (pCount == windowCount) {
            result.push_back(0);
        }
        
        // 滑动窗口
        for (int i = pLen; i < sLen; i++) {
            // 添加右边字符
            windowCount[s[i] - 'a']++;
            // 移除左边字符
            windowCount[s[i - pLen] - 'a']--;
            
            // 检查是否匹配
            if (pCount == windowCount) {
                result.push_back(i - pLen + 1);
            }
        }
        
        return result;
    }
};
```

**代码说明：**
1. 先统计 p 的字符计数
2. 初始化第一个窗口的字符计数
3. 从索引 `pLen` 开始滑动窗口：
   - 添加右边新字符
   - 移除左边旧字符
   - 比较两个计数数组
4. 返回所有匹配的起始索引

### 方法二：优化的有效字符计数

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        int sLen = s.length(), pLen = p.length();
        
        if (sLen < pLen) return result;
        
        // 字符计数差值数组
        vector<int> count(26, 0);
        
        // 统计 p 的字符，初始化窗口
        for (int i = 0; i < pLen; i++) {
            count[p[i] - 'a']++;
            count[s[i] - 'a']--;
        }
        
        // differ 表示有多少个字符的计数不为0
        int differ = 0;
        for (int i = 0; i < 26; i++) {
            if (count[i] != 0) differ++;
        }
        
        // 如果 differ == 0，说明第一个窗口就匹配
        if (differ == 0) {
            result.push_back(0);
        }
        
        // 滑动窗口
        for (int i = pLen; i < sLen; i++) {
            // 添加右边字符
            int right = s[i] - 'a';
            if (count[right] == 0) differ++;
            count[right]--;
            if (count[right] == 0) differ--;
            
            // 移除左边字符
            int left = s[i - pLen] - 'a';
            if (count[left] == 0) differ++;
            count[left]++;
            if (count[left] == 0) differ--;
            
            // 如果 differ == 0，说明找到异位词
            if (differ == 0) {
                result.push_back(i - pLen + 1);
            }
        }
        
        return result;
    }
};
```

**优化说明：**
- 使用一个差值数组：`count[i] = p中字符i的数量 - 窗口中字符i的数量`
- 维护 `differ`：表示有多少个字符的计数不为 0
- 当 `differ == 0` 时，说明所有字符计数都为 0，即窗口是异位词
- 这样避免了每次比较整个数组，只需检查 `differ` 的值

**复杂度分析：**
- 时间复杂度：O(n)，其中 n 是 s 的长度
- 空间复杂度：O(1)，固定大小的计数数组（26）

**易错点：**
1. 窗口大小是固定的 `pLen`，不要搞错
2. 窗口起始索引是 `i - pLen + 1`，不是 `i`
3. 边界情况：`s` 长度小于 `p` 长度时，直接返回空数组
4. 在优化版本中，更新 `differ` 时要注意先判断再修改计数


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

