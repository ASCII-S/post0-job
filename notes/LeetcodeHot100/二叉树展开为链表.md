---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/二叉树展开为链表.md
related_outlines: []
---
# 二叉树展开为链表

## 题目描述

给你二叉树的根结点 `root`，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode`，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null`
- 展开后的单链表应该与二叉树**先序遍历**顺序相同

**示例 1：**
```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**
```
输入：root = []
输出：[]
```

**示例 3：**
```
输入：root = [0]
输出：[0]
```

**提示：**
- 树中结点数在范围 [0, 2000] 内
- -100 <= Node.val <= 100

**进阶：** 你可以使用原地算法（O(1) 额外空间）展开这棵树吗？

## 思路讲解

这道题要求将二叉树展开为链表，顺序与先序遍历相同。

### 核心观察

展开后的链表顺序 = 先序遍历顺序（根-左-右）

### 方法一：先序遍历 + 重建

最直观的方法：
1. 先序遍历树，将节点存入数组
2. 遍历数组，将节点连接成链表形式

**缺点**：需要 O(n) 的额外空间。

### 方法二：递归（后序遍历）

巧妙的递归方法：
1. 递归展开右子树
2. 递归展开左子树
3. 将左子树插入到根节点和右子树之间

### 方法三：迭代（O(1) 空间）

最优方法，利用 Morris 遍历的思想：
1. 对于当前节点，如果左子树存在：
   - 找到左子树的最右节点
   - 将右子树接到左子树的最右节点后面
   - 将左子树移到右边
   - 左指针置为 null
2. 移动到右子节点，重复上述过程

### 关键点

- **先序遍历**：根-左-右
- **原地操作**：修改指针，不创建新节点
- **Morris 遍历思想**：利用叶子节点的空指针来实现无栈遍历

## 面试时的快速口述讲解

这道题要求将二叉树展开为链表，展开后的顺序与先序遍历相同，且要求原地操作。

**数据结构**：
- 方法一：数组存储节点
- 方法二：递归调用栈
- 方法三：只用几个指针变量

**实现方式**：
- **方法一**：先序遍历收集所有节点，然后重建为链表。空间复杂度 O(n)
- **方法二**：递归展开左右子树，将左子树插入根节点和右子树之间
- **方法三（最优）**：对于每个节点，找到左子树的最右节点，将右子树接到它后面，然后将左子树移到右边。这样只需要 O(1) 的额外空间

**时间复杂度**：O(n)，每个节点访问常数次。

**空间复杂度**：
- 方法一：O(n)
- 方法二：O(h)，递归调用栈
- 方法三：O(1)

## 代码实现

### 方法一：先序遍历 + 重建

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        if (root == nullptr) return;
        
        // 先序遍历收集所有节点
        vector<TreeNode*> nodes;
        preorder(root, nodes);
        
        // 重建为链表
        for (int i = 0; i < nodes.size() - 1; i++) {
            nodes[i]->left = nullptr;
            nodes[i]->right = nodes[i + 1];
        }
        if (!nodes.empty()) {
            nodes.back()->left = nullptr;
            nodes.back()->right = nullptr;
        }
    }
    
private:
    void preorder(TreeNode* node, vector<TreeNode*>& nodes) {
        if (node == nullptr) return;
        nodes.push_back(node);
        preorder(node->left, nodes);
        preorder(node->right, nodes);
    }
};
```

### 方法二：递归（后序遍历思想）

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        if (root == nullptr) return;
        
        // 递归展开左右子树
        flatten(root->left);
        flatten(root->right);
        
        // 保存原右子树
        TreeNode* rightSubtree = root->right;
        
        // 将左子树移到右边
        root->right = root->left;
        root->left = nullptr;
        
        // 找到当前右子树的最右节点
        TreeNode* rightmost = root;
        while (rightmost->right != nullptr) {
            rightmost = rightmost->right;
        }
        
        // 将原右子树接到最右节点后面
        rightmost->right = rightSubtree;
    }
};
```

### 方法三：迭代（O(1) 空间，最优解）

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* curr = root;
        
        while (curr != nullptr) {
            // 如果左子树存在
            if (curr->left != nullptr) {
                // 找到左子树的最右节点
                TreeNode* rightmost = curr->left;
                while (rightmost->right != nullptr) {
                    rightmost = rightmost->right;
                }
                
                // 将右子树接到左子树的最右节点后面
                rightmost->right = curr->right;
                
                // 将左子树移到右边
                curr->right = curr->left;
                curr->left = nullptr;
            }
            
            // 移动到下一个节点
            curr = curr->right;
        }
    }
};
```

**代码说明：**

**方法一（先序遍历 + 重建）：**
1. 先序遍历收集所有节点到数组 `nodes`
2. 遍历数组，将相邻节点连接：
   - 左指针置为 null
   - 右指针指向下一个节点
3. 简单直观，但需要 O(n) 的额外空间

**方法二（递归）：**
1. 递归展开左子树和右子树
2. 对于当前节点：
   - 保存原右子树
   - 将左子树移到右边
   - 左指针置为 null
   - 找到新右子树的最右节点
   - 将原右子树接到最右节点后面
3. 采用后序遍历的思想（先处理子树，再处理根）

**方法三（迭代，O(1) 空间）：**
这是最优解，关键思路：

对于当前节点 `curr`：
```
    curr
    /  \
  left right
```

如果 `left` 存在：
1. 找到 `left` 的最右节点 `rightmost`
2. 将 `right` 接到 `rightmost` 后面
3. 将 `left` 移到右边
4. `left` 置为 null

变换后：
```
    curr
      \
     left -> ... -> rightmost -> right
```

然后移动到 `curr.right`，继续处理。

**执行过程示例**（以 [1,2,5,3,4,null,6] 为例）：

```
原树：
    1
   / \
  2   5
 / \   \
3   4   6

步骤1：处理节点1
  - 左子树存在
  - 找到左子树最右节点：4
  - 将5接到4后面
  - 将2移到右边
    1
     \
      2
     / \
    3   4
         \
          5
           \
            6

步骤2：处理节点2
  - 左子树存在
  - 找到左子树最右节点：3
  - 将4接到3后面
  - 将3移到右边
    1
     \
      2
       \
        3
         \
          4
           \
            5
             \
              6

步骤3-6：节点3,4,5,6 都没有左子树，直接移动
最终结果：1->2->3->4->5->6
```

**为什么这是最优解？**
- 时间复杂度：O(n)，每个节点最多被访问两次
- 空间复杂度：O(1)，只使用了几个指针变量
- 原地操作：直接修改指针，不创建新节点
- 利用了 Morris 遍历的思想：使用空闲指针来保存信息

面试中推荐使用**方法三**，既满足了空间要求，又展示了对树的深刻理解。


---

## 相关笔记
<!-- 自动生成 -->

- [二叉树的中序遍历](notes/LeetcodeHot100/二叉树的中序遍历.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树的中序遍历.md
- [反转链表](notes/LeetcodeHot100/反转链表.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/反转链表.md

