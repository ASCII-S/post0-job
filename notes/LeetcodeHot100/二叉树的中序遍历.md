---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/二叉树的中序遍历.md
related_outlines: []
---
# 二叉树的中序遍历

## 题目描述

给定一个二叉树的根节点 `root`，返回它的**中序遍历**结果。

**示例 1：**
```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**
```
输入：root = []
输出：[]
```

**示例 3：**
```
输入：root = [1]
输出：[1]
```

**提示：**
- 树中节点数目在范围 [0, 100] 内
- -100 <= Node.val <= 100

**进阶：** 递归算法很简单，你可以通过迭代算法完成吗？

## 思路讲解

二叉树的中序遍历是指按照"左子树 -> 根节点 -> 右子树"的顺序访问树的所有节点。

### 方法一：递归法

递归是最直观的解法：
1. 如果节点为空，直接返回
2. 递归遍历左子树
3. 访问当前节点（将值加入结果）
4. 递归遍历右子树

**递归三要素：**
- 递归函数参数：当前节点和结果数组
- 终止条件：节点为空
- 单层递归逻辑：左 -> 根 -> 右

### 方法二：迭代法（使用栈）

使用栈来模拟递归过程：
1. 创建一个栈，用于存储待访问的节点
2. 从根节点开始，不断将左子节点压入栈中
3. 当无法继续向左时，弹出栈顶节点，访问该节点
4. 然后转向该节点的右子树，重复上述过程

**关键点：**
- 栈用于回溯到父节点
- 先一直往左走到底，再处理节点，最后处理右子树
- 这个过程模拟了递归的调用栈

## 面试时的快速口述讲解

这道题要求实现二叉树的中序遍历，即按照"左-根-右"的顺序访问所有节点。

**数据结构**：
- 递归法：使用递归调用栈（隐式）
- 迭代法：使用显式栈（stack）

**实现方式**：
- **递归法**：对于每个节点，先递归遍历左子树，再访问当前节点，最后递归遍历右子树
- **迭代法**：使用栈模拟递归过程，不断将左子节点压栈，弹出时访问节点，然后处理右子树

**时间复杂度**：O(n)，每个节点访问一次。

**空间复杂度**：
- 递归法：O(h)，h 是树的高度，最坏情况 O(n)（退化为链表）
- 迭代法：O(h)，栈的最大深度等于树的高度

## 代码实现

### 方法一：递归法

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        inorder(root, result);
        return result;
    }
    
private:
    void inorder(TreeNode* node, vector<int>& result) {
        // 终止条件：节点为空
        if (node == nullptr) {
            return;
        }
        
        // 左 -> 根 -> 右
        inorder(node->left, result);    // 遍历左子树
        result.push_back(node->val);    // 访问根节点
        inorder(node->right, result);   // 遍历右子树
    }
};
```

### 方法二：迭代法（使用栈）

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> stk;
        TreeNode* curr = root;
        
        while (curr != nullptr || !stk.empty()) {
            // 一直往左走，将所有左节点压入栈
            while (curr != nullptr) {
                stk.push(curr);
                curr = curr->left;
            }
            
            // 弹出栈顶节点（此时左子树已处理完）
            curr = stk.top();
            stk.pop();
            
            // 访问当前节点
            result.push_back(curr->val);
            
            // 转向右子树
            curr = curr->right;
        }
        
        return result;
    }
};
```

**代码说明：**

**递归法：**
1. 创建辅助递归函数 `inorder`，接收当前节点和结果数组
2. 如果节点为空，直接返回（递归终止条件）
3. 按照"左-根-右"的顺序递归处理：先处理左子树，再将当前节点值加入结果，最后处理右子树

**迭代法：**
1. 使用栈 `stk` 和当前指针 `curr`
2. 外层循环条件：当前节点不为空或栈不为空
3. 内层循环：一直向左走，将路径上的节点压入栈
4. 弹出栈顶节点，访问该节点（此时其左子树已处理完）
5. 转向右子树，继续处理

迭代法的核心思想是用栈模拟递归的调用栈，手动管理访问顺序。


---

## 相关笔记
<!-- 自动生成 -->

- [二叉树的最大深度](notes/LeetcodeHot100/二叉树的最大深度.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树的最大深度.md
- [翻转二叉树](notes/LeetcodeHot100/翻转二叉树.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/翻转二叉树.md
- [二叉树展开为链表](notes/LeetcodeHot100/二叉树展开为链表.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树展开为链表.md
- [二叉树的层序遍历](notes/LeetcodeHot100/二叉树的层序遍历.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树的层序遍历.md
- [二叉搜索树中第K小的元素](notes/LeetcodeHot100/二叉搜索树中第K小的元素.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/二叉搜索树中第K小的元素.md

