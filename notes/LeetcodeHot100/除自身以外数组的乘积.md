---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/除自身以外数组的乘积.md
related_outlines: []
---
# 除自身以外数组的乘积

## 题目描述

给你一个整数数组 `nums`，返回数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

题目数据保证数组 `nums` 之中任意元素的全部前缀元素和后缀元素的乘积都在 32 位整数范围内。

请**不要使用除法**，且在 O(n) 时间复杂度内完成此题。

**示例 1：**
```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2：**
```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**提示：**
- 2 <= nums.length <= 10^5
- -30 <= nums[i] <= 30
- 保证数组 `nums` 之中任意元素的全部前缀元素和后缀元素的乘积都在 32 位整数范围内

**进阶**：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

## 思路讲解

这道题的关键是**不能使用除法**，且要求 O(n) 时间复杂度。

### 核心思想：前缀积 × 后缀积

对于位置 i，`answer[i]` 应该等于：
- i 左边所有元素的乘积 × i 右边所有元素的乘积

**方法一：使用两个数组**

1. 创建 `prefix` 数组，`prefix[i]` = nums[0] × ... × nums[i-1]（i 左边的乘积）
2. 创建 `suffix` 数组，`suffix[i]` = nums[i+1] × ... × nums[n-1]（i 右边的乘积）
3. `answer[i] = prefix[i] × suffix[i]`

**示例：**
```
nums = [1, 2, 3, 4]

prefix = [1, 1, 2, 6]
         1  1  1×2  1×2×3

suffix = [24, 12, 4, 1]
         2×3×4  3×4  4  1

answer[i] = prefix[i] × suffix[i]
answer = [1×24, 1×12, 2×4, 6×1]
       = [24, 12, 8, 6]
```

**方法二：空间优化到 O(1)**

不使用额外的 prefix 和 suffix 数组，直接在 answer 数组上操作：
1. 第一次遍历：计算左边的乘积，存入 answer
2. 第二次遍历：计算右边的乘积，直接乘到 answer 上

## 面试时的快速口述讲解

这道题要求计算除自身以外所有元素的乘积，不能用除法。

**数据结构**：使用输出数组本身，不需要额外空间。

**实现方式**：
1. 对于每个位置，结果等于"左边所有元素的乘积"乘以"右边所有元素的乘积"
2. 第一次遍历：从左到右，计算每个位置左边的乘积，存入结果数组
3. 第二次遍历：从右到左，计算每个位置右边的乘积，直接乘到结果数组上

**关键点**：
- 使用两个变量维护左边乘积和右边乘积
- 边界处理：最左边元素左边乘积为1，最右边元素右边乘积为1

**时间复杂度**：O(n)，遍历两次数组。

**空间复杂度**：O(1)，不计输出数组。

## 代码实现

### 方法一：使用前缀和后缀数组

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        
        // prefix[i] 表示 i 左边所有元素的乘积
        vector<int> prefix(n, 1);
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] * nums[i - 1];
        }
        
        // suffix[i] 表示 i 右边所有元素的乘积
        vector<int> suffix(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * nums[i + 1];
        }
        
        // 结果 = 左边乘积 × 右边乘积
        vector<int> answer(n);
        for (int i = 0; i < n; i++) {
            answer[i] = prefix[i] * suffix[i];
        }
        
        return answer;
    }
};
```

### 方法二：空间优化 O(1)（推荐）

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> answer(n);
        
        // 第一步：计算左边的乘积
        answer[0] = 1;  // 最左边元素左边没有元素，乘积为1
        for (int i = 1; i < n; i++) {
            answer[i] = answer[i - 1] * nums[i - 1];
        }
        
        // 第二步：计算右边的乘积并直接乘到answer上
        int rightProduct = 1;  // 最右边元素右边没有元素，乘积为1
        for (int i = n - 1; i >= 0; i--) {
            answer[i] *= rightProduct;
            rightProduct *= nums[i];
        }
        
        return answer;
    }
};
```

**代码说明：**

**第一步：计算左边乘积**
```
nums   = [1, 2, 3, 4]
answer = [1, 1, 2, 6]
         1  1  1×2  1×2×3
```

**第二步：计算右边乘积并相乘**
```
i=3: answer[3] = 6 × 1 = 6,    rightProduct = 1 × 4 = 4
i=2: answer[2] = 2 × 4 = 8,    rightProduct = 4 × 3 = 12
i=1: answer[1] = 1 × 12 = 12,  rightProduct = 12 × 2 = 24
i=0: answer[0] = 1 × 24 = 24,  rightProduct = 24 × 1 = 24

answer = [24, 12, 8, 6]
```

**详细注释版本：**
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> answer(n);
        
        // 步骤1：answer[i] = nums[0] * ... * nums[i-1]
        // 即 answer[i] 存储 i 左边所有元素的乘积
        answer[0] = 1;  // 0 左边没有元素
        for (int i = 1; i < n; i++) {
            // i 左边的乘积 = (i-1 左边的乘积) × nums[i-1]
            answer[i] = answer[i - 1] * nums[i - 1];
        }
        
        // 步骤2：从右向左遍历，计算右边的乘积
        // 并将右边乘积乘到 answer 上
        int rightProduct = 1;  // 维护当前位置右边所有元素的乘积
        
        for (int i = n - 1; i >= 0; i--) {
            // answer[i] 已经存了左边的乘积
            // 现在乘上右边的乘积，得到最终结果
            answer[i] *= rightProduct;
            
            // 更新右边乘积：加入当前元素
            rightProduct *= nums[i];
        }
        
        return answer;
    }
};
```

**复杂度分析：**
- 时间复杂度：O(n)
  - 第一次遍历：O(n)
  - 第二次遍历：O(n)
- 空间复杂度：O(1)
  - 不计输出数组 answer
  - 只使用常数额外空间

**易错点：**
1. 边界条件的初始化：
   - `answer[0] = 1`（左边没有元素）
   - `rightProduct = 1`（右边没有元素）
2. 第二次遍历是从右向左
3. 更新 `rightProduct` 要在使用之后
4. 理解 `answer[i] *= rightProduct` 的含义：左边乘积已经在 answer[i] 中了

**如果允许使用除法怎么做？**
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        int totalProduct = 1;
        int zeroCount = 0;
        
        // 计算所有非零元素的乘积
        for (int num : nums) {
            if (num == 0) {
                zeroCount++;
            } else {
                totalProduct *= num;
            }
        }
        
        vector<int> answer(n);
        
        for (int i = 0; i < n; i++) {
            if (zeroCount > 1) {
                // 有2个或以上的0，所有结果都是0
                answer[i] = 0;
            } else if (zeroCount == 1) {
                // 只有1个0
                answer[i] = (nums[i] == 0) ? totalProduct : 0;
            } else {
                // 没有0
                answer[i] = totalProduct / nums[i];
            }
        }
        
        return answer;
    }
};
```

但题目要求不使用除法，所以上面的方法不符合要求，仅供理解。


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

