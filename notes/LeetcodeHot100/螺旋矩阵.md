---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/螺旋矩阵.md
related_outlines: []
---
# 螺旋矩阵

## 题目描述

给你一个 `m` 行 `n` 列的矩阵 `matrix`，请按照**顺时针螺旋顺序**，返回矩阵中的所有元素。

**示例 1：**
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**
```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**提示：**
- m == matrix.length
- n == matrix[i].length
- 1 <= m, n <= 10
- -100 <= matrix[i][j] <= 100

## 思路讲解

螺旋遍历的关键是**维护边界**。

### 按层遍历

**核心思想：**
将矩阵看作一层层的边框，从外到内逐层遍历。

**每一层的遍历顺序：**
1. 从左到右遍历上边界
2. 从上到下遍历右边界
3. 从右到左遍历下边界（如果还有下边界）
4. 从下到上遍历左边界（如果还有左边界）

**边界维护：**
- `top`：上边界行号
- `bottom`：下边界行号
- `left`：左边界列号
- `right`：右边界列号

**算法步骤：**
1. 初始化四个边界
2. 循环遍历每一层：
   - 遍历上边界：从 left 到 right
   - 遍历右边界：从 top+1 到 bottom
   - 如果还有下边界（top < bottom），从右到左遍历
   - 如果还有左边界（left < right），从下到上遍历
3. 收缩边界，继续下一层

**示例演示：**
```
matrix = [[1,2,3],
          [4,5,6],
          [7,8,9]]

初始边界：top=0, bottom=2, left=0, right=2

第一层：
1. 上边界：1→2→3 (row=0, col: 0→2)
2. 右边界：6→9 (col=2, row: 1→2)
3. 下边界：8→7 (row=2, col: 2→0)
4. 左边界：4 (col=0, row: 1→1)

收缩边界：top=1, bottom=1, left=1, right=1

第二层：
1. 上边界：5 (row=1, col=1)

完成，结果：[1,2,3,6,9,8,7,4,5]
```

## 面试时的快速口述讲解

这道题要按顺时针螺旋顺序遍历矩阵。

**数据结构**：四个变量维护边界（上下左右）。

**实现方式**：
1. 维护四个边界：top、bottom、left、right
2. 每一圈按顺序遍历四条边：
   - 上边界：从左到右
   - 右边界：从上到下
   - 下边界：从右到左（如果还有）
   - 左边界：从下到上（如果还有）
3. 遍历完一圈后收缩边界，继续下一圈
4. 直到所有元素都被访问

**关键点**：
- 每遍历完一条边就收缩对应边界
- 遍历下边界和左边界时要检查是否还有（避免重复）
- 循环条件：`top <= bottom && left <= right`

**时间复杂度**：O(m × n)，访问每个元素一次。

**空间复杂度**：O(1)，不计结果数组。

## 代码实现

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.empty()) return {};
        
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> result;
        
        int top = 0, bottom = m - 1;
        int left = 0, right = n - 1;
        
        while (top <= bottom && left <= right) {
            // 1. 从左到右遍历上边界
            for (int col = left; col <= right; col++) {
                result.push_back(matrix[top][col]);
            }
            top++;  // 上边界下移
            
            // 2. 从上到下遍历右边界
            for (int row = top; row <= bottom; row++) {
                result.push_back(matrix[row][right]);
            }
            right--;  // 右边界左移
            
            // 3. 从右到左遍历下边界（如果还有下边界）
            if (top <= bottom) {
                for (int col = right; col >= left; col--) {
                    result.push_back(matrix[bottom][col]);
                }
                bottom--;  // 下边界上移
            }
            
            // 4. 从下到上遍历左边界（如果还有左边界）
            if (left <= right) {
                for (int row = bottom; row >= top; row--) {
                    result.push_back(matrix[row][left]);
                }
                left++;  // 左边界右移
            }
        }
        
        return result;
    }
};
```

**代码说明：**
1. 初始化四个边界
2. 当 `top <= bottom && left <= right` 时循环：
   - 遍历上边界，然后 `top++`
   - 遍历右边界，然后 `right--`
   - 如果还有下边界（`top <= bottom`），遍历下边界，然后 `bottom--`
   - 如果还有左边界（`left <= right`），遍历左边界，然后 `left++`
3. 返回结果

**为什么要检查 `top <= bottom` 和 `left <= right`？**

考虑这种情况：
```
matrix = [[1,2,3]]  (只有一行)

第一步：遍历上边界 [1,2,3], top=1, bottom=0
第二步：遍历右边界 [3]（重复！）

所以第三步遍历下边界时要检查 top <= bottom
```

另一种情况：
```
matrix = [[1],
          [2],
          [3]]  (只有一列)

第一步：遍历上边界 [1], top=1
第二步：遍历右边界 [2,3], right=-1, left=0
第三步：遍历下边界 [3]（重复！）

所以第四步遍历左边界时要检查 left <= right
```

**方向数组版本：**
```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.empty()) return {};
        
        int m = matrix.size(), n = matrix[0].size();
        vector<int> result;
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        
        // 方向数组：右、下、左、上
        int dr[] = {0, 1, 0, -1};
        int dc[] = {1, 0, -1, 0};
        
        int r = 0, c = 0, dir = 0;
        
        for (int i = 0; i < m * n; i++) {
            result.push_back(matrix[r][c]);
            visited[r][c] = true;
            
            // 计算下一个位置
            int nr = r + dr[dir];
            int nc = c + dc[dir];
            
            // 如果下一个位置越界或已访问，改变方向
            if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {
                dir = (dir + 1) % 4;  // 顺时针转向
                nr = r + dr[dir];
                nc = c + dc[dir];
            }
            
            r = nr;
            c = nc;
        }
        
        return result;
    }
};
```

这个版本使用方向数组和访问标记，逻辑更清晰但需要额外空间。

**复杂度分析：**
- 时间复杂度：O(m × n)，访问每个元素一次
- 空间复杂度：
  - 边界法：O(1)
  - 方向数组法：O(m × n)（visited 数组）

**易错点：**
1. 遍历下边界和左边界前要检查是否还有剩余
2. 边界更新的时机：每遍历完一条边就更新
3. 循环条件：`top <= bottom && left <= right`
4. 单行或单列矩阵的特殊情况

**相关问题：**
- 螺旋矩阵 II（生成螺旋矩阵）
- 旋转图像


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

