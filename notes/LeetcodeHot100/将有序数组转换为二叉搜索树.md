---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/将有序数组转换为二叉搜索树.md
related_outlines: []
---
# 将有序数组转换为二叉搜索树

## 题目描述

给你一个整数数组 `nums`，其中元素已经按**升序**排列，请你将其转换为一棵**平衡二叉搜索树**。

**平衡二叉树** 是指该树所有节点的左右子树的高度差的绝对值不超过 1。

**示例 1：**
```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案。
```

**示例 2：**
```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

**提示：**
- 1 <= nums.length <= 10^4
- -10^4 <= nums[i] <= 10^4
- `nums` 按**严格递增**顺序排列

## 思路讲解

这道题结合了二叉搜索树（BST）和平衡的概念。

### 核心思想

1. **BST 的性质**：中序遍历是升序的
2. **反向思考**：给定升序数组，相当于给定了 BST 的中序遍历结果
3. **平衡的关键**：选择中间元素作为根节点，左右两边长度相近，自然平衡

### 解题步骤

使用分治法（递归）：
1. 选择数组的中间元素作为根节点
2. 中间元素左边的所有元素构建左子树
3. 中间元素右边的所有元素构建右子树
4. 递归地对左右子数组执行相同操作

### 为什么选择中间元素？

- **平衡性**：中间元素能保证左右子树的节点数量相差不超过 1
- **BST 性质**：中间元素左边的都小于它，右边的都大于它
- **最优解**：这样构造的树高度最小，为 ⌈log₂(n+1)⌉

### 关键点

- 中间元素的选择：`mid = left + (right - left) / 2`
- 递归的边界：`left > right` 时返回空节点
- 左子树范围：`[left, mid-1]`
- 右子树范围：`[mid+1, right]`

## 面试时的快速口述讲解

这道题要求将有序数组转换为平衡二叉搜索树。

**数据结构**：使用递归构建二叉树。

**实现方式**：
1. 使用分治法，选择数组的中间元素作为根节点
2. 中间元素左边的部分递归构建左子树
3. 中间元素右边的部分递归构建右子树
4. 这样构造出的树天然满足 BST 性质（中序遍历有序）和平衡性（左右子树高度差不超过 1）

**时间复杂度**：O(n)，每个元素访问一次，用于创建对应的树节点。

**空间复杂度**：O(log n)，递归调用栈的深度，等于树的高度。

## 代码实现

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildBST(nums, 0, nums.size() - 1);
    }
    
private:
    TreeNode* buildBST(vector<int>& nums, int left, int right) {
        // 递归终止条件：区间为空
        if (left > right) {
            return nullptr;
        }
        
        // 选择中间元素作为根节点
        // 这里取中间偏左的元素，也可以取中间偏右的
        int mid = left + (right - left) / 2;
        
        // 创建根节点
        TreeNode* root = new TreeNode(nums[mid]);
        
        // 递归构建左右子树
        root->left = buildBST(nums, left, mid - 1);
        root->right = buildBST(nums, mid + 1, right);
        
        return root;
    }
};
```

**代码说明：**

1. **主函数 `sortedArrayToBST`**：
   - 调用辅助函数 `buildBST`
   - 传入数组和初始的左右边界（0 和 n-1）

2. **辅助函数 `buildBST`**：
   - **参数**：数组 `nums`，当前区间的左右边界 `left` 和 `right`
   - **返回值**：构建的子树的根节点
   - **递归终止条件**：`left > right` 表示区间为空，返回 nullptr
   - **递归逻辑**：
     - 计算中间位置：`mid = left + (right - left) / 2`
     - 创建根节点，值为 `nums[mid]`
     - 递归构建左子树：范围 `[left, mid-1]`
     - 递归构建右子树：范围 `[mid+1, right]`
     - 返回根节点

**执行过程示例**（以 [-10,-3,0,5,9] 为例）：

```
buildBST(nums, 0, 4):
  mid = 2, root = 0
  
  左子树：buildBST(nums, 0, 1):
    mid = 0, root = -10
    左子树：buildBST(nums, 0, -1) -> null
    右子树：buildBST(nums, 1, 1):
      mid = 1, root = -3
      左右子树都为 null
    返回 -10 -> -3
  
  右子树：buildBST(nums, 3, 4):
    mid = 3, root = 5
    左子树：buildBST(nums, 3, 2) -> null
    右子树：buildBST(nums, 4, 4):
      mid = 4, root = 9
      左右子树都为 null
    返回 5 -> 9
  
  返回树：
       0
      / \
    -10  5
      \   \
      -3   9
```

**为什么这样是平衡的？**
- 每次选择中间元素，左右两边的元素数量相差不超过 1
- 递归地在左右子数组上执行相同操作
- 每个子树的左右子树高度差不超过 1
- 整棵树的高度为 O(log n)，是最优的

**注意事项：**
- 中间元素的选择可以是 `mid = (left + right) / 2` 或 `mid = (left + right + 1) / 2`
- 前者选中间偏左，后者选中间偏右，都是正确的
- 使用 `left + (right - left) / 2` 可以避免整数溢出
- 答案不唯一，任何满足条件的平衡 BST 都是正确答案


---

## 相关笔记
<!-- 自动生成 -->

- [从前序与中序遍历序列构造二叉树](notes/LeetcodeHot100/从前序与中序遍历序列构造二叉树.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/从前序与中序遍历序列构造二叉树.md
- [验证二叉搜索树](notes/LeetcodeHot100/验证二叉搜索树.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/验证二叉搜索树.md

