---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/虚函数的实现机制（虚函数表）.md
related_outlines: []
---
# 虚函数的实现机制（虚函数表）

**1. 一个对象里有几个 vptr（虚函数指针）？**

* 情况一：**单继承**
  类有虚函数 → 对象里有 **一个 vptr**。
* 情况二：**多重继承**，多个基类各自有虚函数
  每个有虚函数的基类子对象都会在派生类对象里携带一个自己的 vptr。
  因为编译器要保证：通过任意一个基类指针访问虚函数，都能顺利找到该基类对应的虚函数表。
  所以结论是：**一个派生类对象里可能会有多个 vptr，数量等于“含虚函数的基类子对象数”**。

举个例子：

```cpp
struct A { virtual void f(); };
struct B { virtual void g(); };
struct C : A, B { }; 
```

对象 `C` 的布局大概是：

```
[C object]
  vptr_A → vtable_A
  A's data...
  vptr_B → vtable_B
  B's data...
  C's own data...
```

所以 `C` 的对象里有 **两个 vptr**。

---

**2. vtable 是“对象拥有”还是“类拥有”？**

* **vtable 是类级别的，全局唯一的表**，编译期生成，存放在只读段里。
* **vptr 是对象级别的**，每个对象实例里存一个指针，指向它所属类的 vtable。
* 所以对象不是真的“拥有”一张表，而是“拥有一个指针”，通过这个指针找到类共享的表。

---

**3. vtable 里一般长什么样子？**
不同 ABI 会有差别，但典型布局是：

* 一个数组，每个槽位是一个函数指针。
* 槽的顺序对应源码里声明的虚函数顺序。
* 如果有覆盖（override），表项会被替换成派生类的实现。
* 如果是多重继承，还可能包含偏移信息，用来调整 `this` 指针。

例子：

```cpp
struct A { virtual void f(); };
struct B { virtual void g(); };
struct C : A, B { virtual void f(); void g(); };
```

生成的大概是：

* `vtable_A_for_C` = { `C::f` }
* `vtable_B_for_C` = { `C::g` }

而 `C` 对象里有两个 vptr，分别指向这两张表。

---

**4. 面试式总结**
“在多重继承下，如果多个父类都有虚函数，那么派生类对象里会有多个 vptr，每个带虚函数的基类子对象都会携带一个。虚函数表不是对象私有的，而是类级别的，每个类在编译时生成一份 vtable，存放在只读段里，所有对象共享。对象只是通过自己的 vptr 指针去引用这些 vtable。这样无论你通过哪一个基类指针调用虚函数，都能正确分派到派生类的实现。”

---

## 相关笔记
<!-- 自动生成 -->

- [调用虚函数的执行流程](notes/C++/调用虚函数的执行流程.md) - 相似度: 33% | 标签: C++, C++/调用虚函数的执行流程.md
- [类继承中的内存布局](notes/C++/类继承中的内存布局.md) - 相似度: 31% | 标签: C++, C++/类继承中的内存布局.md

