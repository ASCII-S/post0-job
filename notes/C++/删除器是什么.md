---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/删除器是什么.md
related_outlines: []
---
# 删除器是什么？

## 面试标准答案（可背诵）

**删除器（Deleter）是智能指针用于自定义资源释放方式的可调用对象。**

**核心要点**：
1. **默认删除器**：`unique_ptr` 和 `shared_ptr` 默认使用 `delete`（单个对象）或 `delete[]`（数组）
2. **自定义删除器**：可以指定函数、lambda、函数对象来自定义资源释放逻辑
3. **使用场景**：管理非内存资源（文件、句柄、连接）、C API 资源、特殊释放逻辑
4. **类型差异**：
   - `unique_ptr`：删除器是类型的一部分，零开销（无删除器时）
   - `shared_ptr`：删除器不是类型的一部分，存储在控制块中

**典型应用**：管理 FILE*、socket、数据库连接、系统资源句柄等 C 风格资源。

---

## 详细解析

### 1. 删除器的基本概念

#### 1.1 默认删除器

```cpp
#include <memory>

void default_deleter_demo() {
    // unique_ptr 默认删除器：使用 delete
    {
        std::unique_ptr<int> ptr(new int(42));
        // 作用域结束时调用：delete ptr.get();
    }
    
    // unique_ptr 数组版本：使用 delete[]
    {
        std::unique_ptr<int[]> arr(new int[10]);
        // 作用域结束时调用：delete[] arr.get();
    }
    
    // shared_ptr 默认删除器：也是 delete
    {
        std::shared_ptr<int> ptr(new int(42));
        // 引用计数归零时调用：delete ptr.get();
    }
}
```

#### 1.2 为什么需要自定义删除器

```cpp
// 场景1：C 风格资源（不是用 new 分配的）
void file_example() {
    FILE* file = fopen("data.txt", "r");
    // delete file;  // ✗ 错误！应该用 fclose
    fclose(file);    // ✓ 正确
}

// 场景2：特殊的释放逻辑
void custom_allocation() {
    void* memory = custom_allocate(1024);
    // delete memory;  // ✗ 错误！
    custom_free(memory);  // ✓ 正确
}

// 场景3：资源池管理（归还而非删除）
void pool_example() {
    Object* obj = pool.acquire();
    // delete obj;  // ✗ 错误！应该归还池中
    pool.release(obj);  // ✓ 正确
}

// 使用删除器可以让智能指针自动处理这些特殊情况
```

### 2. unique_ptr 的删除器

#### 2.1 函数删除器

```cpp
#include <cstdio>

// 删除器函数
void file_closer(FILE* fp) {
    if (fp) {
        std::cout << "关闭文件" << std::endl;
        fclose(fp);
    }
}

void function_deleter_example() {
    // 指定删除器类型和实例
    std::unique_ptr<FILE, decltype(&file_closer)> file(
        fopen("data.txt", "w"),
        &file_closer  // 删除器实例
    );
    
    if (file) {
        fprintf(file.get(), "Hello, World!\n");
    }
    
    // 作用域结束时自动调用 file_closer(file.get())
}

// 使用别名简化
using FilePtr = std::unique_ptr<FILE, decltype(&fclose)>;

void simplified_example() {
    FilePtr file(fopen("data.txt", "r"), &fclose);
    
    if (file) {
        char buffer[256];
        fgets(buffer, sizeof(buffer), file.get());
    }
}
```

#### 2.2 Lambda 删除器

```cpp
void lambda_deleter_example() {
    // Lambda 作为删除器
    auto deleter = [](int* ptr) {
        std::cout << "删除值为 " << *ptr << " 的对象" << std::endl;
        delete ptr;
    };
    
    std::unique_ptr<int, decltype(deleter)> ptr(new int(42), deleter);
    
    // 更简洁的写法
    auto file = std::unique_ptr<FILE, decltype(&fclose)>(
        fopen("data.txt", "r"),
        &fclose
    );
}

// 带捕获的 lambda
void lambda_with_capture() {
    std::string filename = "data.txt";
    
    auto deleter = [filename](FILE* fp) {
        if (fp) {
            std::cout << "关闭文件: " << filename << std::endl;
            fclose(fp);
        }
    };
    
    std::unique_ptr<FILE, decltype(deleter)> file(
        fopen(filename.c_str(), "w"),
        deleter
    );
}
```

#### 2.3 函数对象删除器

```cpp
// 删除器类
struct FileDeleter {
    void operator()(FILE* fp) const {
        if (fp) {
            std::cout << "FileDeleter 关闭文件" << std::endl;
            fclose(fp);
        }
    }
};

void functor_deleter_example() {
    std::unique_ptr<FILE, FileDeleter> file(
        fopen("data.txt", "w"),
        FileDeleter{}
    );
    
    if (file) {
        fprintf(file.get(), "Using functor deleter\n");
    }
}

// 带状态的删除器
struct LoggingDeleter {
    std::string tag;
    
    LoggingDeleter(const std::string& t) : tag(t) {}
    
    void operator()(int* ptr) const {
        std::cout << "[" << tag << "] 删除对象: " << *ptr << std::endl;
        delete ptr;
    }
};

void stateful_deleter() {
    std::unique_ptr<int, LoggingDeleter> ptr(
        new int(100),
        LoggingDeleter("MyTag")
    );
}
```

#### 2.4 unique_ptr 删除器的类型影响

```cpp
void deleter_type_matters() {
    // 无自定义删除器：sizeof = 8 字节（仅指针）
    std::unique_ptr<int> ptr1(new int(42));
    std::cout << "无删除器大小: " << sizeof(ptr1) << std::endl;  // 8
    
    // 函数指针删除器：sizeof = 16 字节（指针 + 函数指针）
    std::unique_ptr<FILE, decltype(&fclose)> ptr2(nullptr, &fclose);
    std::cout << "函数指针删除器大小: " << sizeof(ptr2) << std::endl;  // 16
    
    // 空类删除器（EBO优化）：sizeof = 8 字节
    struct EmptyDeleter {
        void operator()(int* p) const { delete p; }
    };
    std::unique_ptr<int, EmptyDeleter> ptr3(new int(42));
    std::cout << "空类删除器大小: " << sizeof(ptr3) << std::endl;  // 8
    
    // 带状态的删除器：sizeof = 更大
    struct StatefulDeleter {
        int state;
        void operator()(int* p) const { delete p; }
    };
    std::unique_ptr<int, StatefulDeleter> ptr4(new int(42), StatefulDeleter{100});
    std::cout << "带状态删除器大小: " << sizeof(ptr4) << std::endl;  // > 8
}
```

### 3. shared_ptr 的删除器

#### 3.1 基本用法

```cpp
void shared_ptr_deleter() {
    // 函数删除器
    std::shared_ptr<FILE> file1(
        fopen("data.txt", "w"),
        &fclose
    );
    
    // Lambda 删除器
    std::shared_ptr<FILE> file2(
        fopen("data.txt", "r"),
        [](FILE* fp) {
            if (fp) {
                std::cout << "Lambda 关闭文件" << std::endl;
                fclose(fp);
            }
        }
    );
    
    // 函数对象删除器
    std::shared_ptr<int> ptr(
        new int(42),
        [](int* p) {
            std::cout << "删除 int: " << *p << std::endl;
            delete p;
        }
    );
}
```

#### 3.2 删除器不影响类型

```cpp
void deleter_type_independence() {
    // 不同删除器的 shared_ptr 是同一类型！
    auto deleter1 = [](int* p) { 
        std::cout << "删除器1" << std::endl;
        delete p; 
    };
    
    auto deleter2 = [](int* p) { 
        std::cout << "删除器2" << std::endl;
        delete p; 
    };
    
    std::shared_ptr<int> ptr1(new int(1), deleter1);
    std::shared_ptr<int> ptr2(new int(2), deleter2);
    
    // ✓ 类型相同，可以相互赋值
    ptr1 = ptr2;  // 正确！
    
    // sizeof 始终相同（删除器存储在控制块中）
    std::cout << "ptr1 大小: " << sizeof(ptr1) << std::endl;  // 16
    std::cout << "ptr2 大小: " << sizeof(ptr2) << std::endl;  // 16
}

// unique_ptr 的对比
void unique_ptr_type_dependence() {
    auto deleter1 = [](int* p) { delete p; };
    auto deleter2 = [](int* p) { delete p; };
    
    std::unique_ptr<int, decltype(deleter1)> uptr1(new int(1), deleter1);
    std::unique_ptr<int, decltype(deleter2)> uptr2(new int(2), deleter2);
    
    // ✗ 类型不同，不能相互赋值
    // uptr1 = uptr2;  // 编译错误！
}
```

#### 3.3 shared_ptr 删除器的灵活性

```cpp
void shared_ptr_flexibility() {
    // 可以使用不同删除器创建，然后放在同一容器中
    std::vector<std::shared_ptr<void>> resources;
    
    // 添加文件资源
    resources.push_back(
        std::shared_ptr<void>(fopen("file1.txt", "r"), &fclose)
    );
    
    // 添加内存资源
    resources.push_back(
        std::shared_ptr<void>(malloc(1024), &free)
    );
    
    // 添加自定义资源
    resources.push_back(
        std::shared_ptr<void>(
            create_socket(),
            [](void* s) { close_socket(s); }
        )
    );
    
    // 所有资源在 vector 销毁时自动释放
    // 每个使用正确的删除器
}
```

### 4. 实际应用场景

#### 4.1 管理 C API 资源

```cpp
// Socket 管理
class SocketDeleter {
public:
    void operator()(int* sock) const {
        if (sock && *sock >= 0) {
            std::cout << "关闭 socket: " << *sock << std::endl;
            // close(*sock);
            delete sock;
        }
    }
};

using SocketPtr = std::unique_ptr<int, SocketDeleter>;

SocketPtr create_socket() {
    int sock = 42;  // socket(...)
    return SocketPtr(new int(sock), SocketDeleter{});
}

// 数据库连接管理
struct DBDeleter {
    void operator()(void* db) const {
        if (db) {
            std::cout << "断开数据库连接" << std::endl;
            // db_disconnect(db);
        }
    }
};

void database_example() {
    std::unique_ptr<void, DBDeleter> db(
        /* db_connect() */ nullptr,
        DBDeleter{}
    );
}
```

#### 4.2 资源池管理

```cpp
template<typename T>
class ObjectPool {
    std::vector<std::unique_ptr<T>> pool_;
    std::vector<T*> available_;
    
public:
    // 获取对象，返回带自定义删除器的 shared_ptr
    std::shared_ptr<T> acquire() {
        T* obj;
        
        if (available_.empty()) {
            obj = new T();
            pool_.push_back(std::unique_ptr<T>(obj));
        } else {
            obj = available_.back();
            available_.pop_back();
        }
        
        // 删除器：归还对象到池中，而非删除
        return std::shared_ptr<T>(
            obj,
            [this](T* p) {
                std::cout << "对象归还池中" << std::endl;
                this->release(p);
            }
        );
    }
    
private:
    void release(T* obj) {
        available_.push_back(obj);
    }
};

void pool_example() {
    ObjectPool<Widget> pool;
    
    {
        auto obj1 = pool.acquire();
        auto obj2 = pool.acquire();
        
        // 使用对象
        
    }  // obj1 和 obj2 自动归还池中，而非被删除
    
    auto obj3 = pool.acquire();  // 重用之前的对象
}
```

#### 4.3 数组删除器

```cpp
void array_deleter_example() {
    // 错误示范
    // std::shared_ptr<int> bad(new int[10]);  // ⚠️ 会调用 delete，应该是 delete[]
    
    // 正确方式1：使用数组删除器
    std::shared_ptr<int> arr1(
        new int[10],
        [](int* p) { delete[] p; }  // 自定义删除器使用 delete[]
    );
    
    // 正确方式2：使用 std::default_delete
    std::shared_ptr<int> arr2(
        new int[10],
        std::default_delete<int[]>()
    );
    
    // 注意：unique_ptr 有专门的数组版本
    std::unique_ptr<int[]> arr3(new int[10]);  // ✓ 自动使用 delete[]
}
```

#### 4.4 自定义内存管理

```cpp
// 使用自定义分配器和删除器
void* custom_allocate(size_t size) {
    std::cout << "自定义分配 " << size << " 字节" << std::endl;
    return ::operator new(size);
}

void custom_deallocate(void* ptr) {
    std::cout << "自定义释放" << std::endl;
    ::operator delete(ptr);
}

void custom_memory_management() {
    // 使用自定义内存管理
    std::shared_ptr<int> ptr(
        static_cast<int*>(custom_allocate(sizeof(int))),
        [](int* p) {
            custom_deallocate(p);
        }
    );
    
    new (ptr.get()) int(42);  // placement new
    
    std::cout << "值: " << *ptr << std::endl;
    
    // 自动调用自定义释放函数
}
```

### 5. 删除器的高级技巧

#### 5.1 空删除器（不删除）

```cpp
void no_delete_example() {
    int stack_value = 42;
    
    // 栈对象的 shared_ptr，使用空删除器
    std::shared_ptr<int> ptr(
        &stack_value,
        [](int*) { /* 什么都不做 */ }
    );
    
    std::cout << *ptr << std::endl;  // 可以正常使用
    
    // 作用域结束时不会删除 stack_value（因为空删除器）
}

// 实际应用：包装现有对象
class LegacySystem {
    static Widget global_widget;
    
public:
    // 返回全局对象的 shared_ptr，但不删除它
    static std::shared_ptr<Widget> get_widget() {
        return std::shared_ptr<Widget>(
            &global_widget,
            [](Widget*) { /* 不删除全局对象 */ }
        );
    }
};
```

#### 5.2 条件删除器

```cpp
class ConditionalDeleter {
    bool should_delete_;
    
public:
    ConditionalDeleter(bool should_delete) 
        : should_delete_(should_delete) {}
    
    void operator()(int* ptr) const {
        if (should_delete_) {
            std::cout << "删除对象" << std::endl;
            delete ptr;
        } else {
            std::cout << "跳过删除" << std::endl;
        }
    }
};

void conditional_delete() {
    bool is_owner = true;
    
    std::unique_ptr<int, ConditionalDeleter> ptr(
        new int(42),
        ConditionalDeleter(is_owner)
    );
    
    // 根据 is_owner 决定是否删除
}
```

#### 5.3 删除器链

```cpp
template<typename T, typename D1, typename D2>
class ChainedDeleter {
    D1 deleter1_;
    D2 deleter2_;
    
public:
    ChainedDeleter(D1 d1, D2 d2) 
        : deleter1_(d1), deleter2_(d2) {}
    
    void operator()(T* ptr) const {
        deleter1_(ptr);
        deleter2_(ptr);
    }
};

void chained_deleter_example() {
    auto log_deleter = [](int* p) {
        std::cout << "记录删除: " << *p << std::endl;
    };
    
    auto actual_deleter = [](int* p) {
        delete p;
    };
    
    using Deleter = ChainedDeleter<int, decltype(log_deleter), decltype(actual_deleter)>;
    
    std::unique_ptr<int, Deleter> ptr(
        new int(42),
        Deleter(log_deleter, actual_deleter)
    );
    
    // 删除时会先记录，再实际删除
}
```

### 6. 删除器的性能考虑

#### 6.1 大小和性能对比

```cpp
void performance_comparison() {
    // unique_ptr: 删除器影响类型和大小
    std::unique_ptr<int> u1(new int(1));  // 8 字节
    std::unique_ptr<int, void(*)(int*)> u2(new int(2), [](int* p) { delete p; });  // 16 字节
    
    // shared_ptr: 删除器不影响类型和大小
    std::shared_ptr<int> s1(new int(1));  // 16 字节
    std::shared_ptr<int> s2(new int(2), [](int* p) { delete p; });  // 16 字节
    
    std::cout << "u1: " << sizeof(u1) << std::endl;
    std::cout << "u2: " << sizeof(u2) << std::endl;
    std::cout << "s1: " << sizeof(s1) << std::endl;
    std::cout << "s2: " << sizeof(s2) << std::endl;
}
```

#### 6.2 EBO 优化（Empty Base Optimization）

```cpp
// 空删除器可以利用 EBO 优化
struct EmptyDeleter {
    void operator()(int* p) const {
        delete p;
    }
};

void ebo_optimization() {
    // 空类删除器，编译器可能优化为零开销
    std::unique_ptr<int, EmptyDeleter> ptr(new int(42));
    
    std::cout << "大小: " << sizeof(ptr) << std::endl;  // 可能是 8
    
    // 对比带状态的删除器
    struct StatefulDeleter {
        int state = 0;
        void operator()(int* p) const { delete p; }
    };
    
    std::unique_ptr<int, StatefulDeleter> ptr2(new int(42));
    std::cout << "大小: " << sizeof(ptr2) << std::endl;  // 可能是 16
}
```

### 7. 实战示例：通用资源包装器

```cpp
// 通用 RAII 资源包装器
template<typename Resource, typename Deleter>
class ResourceWrapper {
    Resource resource_;
    Deleter deleter_;
    bool owns_;
    
public:
    ResourceWrapper(Resource res, Deleter del) 
        : resource_(res), deleter_(del), owns_(true) {}
    
    ~ResourceWrapper() {
        if (owns_) {
            deleter_(resource_);
        }
    }
    
    // 禁止拷贝
    ResourceWrapper(const ResourceWrapper&) = delete;
    ResourceWrapper& operator=(const ResourceWrapper&) = delete;
    
    // 支持移动
    ResourceWrapper(ResourceWrapper&& other) noexcept
        : resource_(other.resource_)
        , deleter_(std::move(other.deleter_))
        , owns_(other.owns_) {
        other.owns_ = false;
    }
    
    Resource get() const { return resource_; }
    
    void release() { owns_ = false; }
};

// 辅助函数
template<typename Resource, typename Deleter>
auto make_resource(Resource res, Deleter del) {
    return ResourceWrapper<Resource, Deleter>(res, del);
}

void wrapper_example() {
    // 文件资源
    auto file = make_resource(
        fopen("data.txt", "w"),
        [](FILE* fp) {
            if (fp) {
                std::cout << "关闭文件" << std::endl;
                fclose(fp);
            }
        }
    );
    
    if (file.get()) {
        fprintf(file.get(), "Hello\n");
    }
    
    // 自动关闭
}
```

### 8. 对比总结

| 特性                   | unique_ptr 删除器              | shared_ptr 删除器        |
| ---------------------- | ------------------------------ | ------------------------ |
| **是否是类型的一部分** | ✓ 是（影响类型）               | ✗ 否（不影响类型）       |
| **存储位置**           | 对象内部                       | 控制块中                 |
| **大小影响**           | 影响 unique_ptr 大小           | 不影响 shared_ptr 大小   |
| **EBO 优化**           | 支持（空删除器零开销）         | 不适用                   |
| **类型兼容性**         | 不同删除器类型不兼容           | 不同删除器类型兼容       |
| **默认值**             | `std::default_delete<T>`       | `std::default_delete<T>` |
| **数组支持**           | 自动（`unique_ptr<T[]>`）      | 需要自定义删除器         |
| **性能**               | 零开销（无删除器或空删除器时） | 稍有开销（函数调用间接） |

### 9. 核心要点

**什么是删除器？**
- 可调用对象，用于自定义资源释放方式
- 可以是函数、lambda、函数对象
- 默认使用 `delete` 或 `delete[]`

**何时使用自定义删除器？**
- ✓ 管理 C API 资源（FILE*、socket、数据库连接）
- ✓ 使用自定义内存分配器
- ✓ 资源池管理（归还而非删除）
- ✓ 需要特殊清理逻辑

**unique_ptr vs shared_ptr 删除器？**
- `unique_ptr`：删除器是类型一部分，性能更优，但类型不兼容
- `shared_ptr`：删除器存储在控制块，类型兼容，更灵活

**最佳实践**：
1. 优先使用默认删除器（`delete`/`delete[]`）
2. 管理非内存资源时使用自定义删除器
3. `unique_ptr` 优先使用空类删除器（EBO 优化）
4. `shared_ptr` 适合需要类型兼容性的场景

**记住**：删除器让智能指针不仅能管理内存，还能管理任何需要释放的资源，是 RAII 的完美体现。


---

## 相关笔记
<!-- 自动生成 -->

- [unique_ptr](notes/C++/unique_ptr.md) - 相似度: 31% | 标签: C++, C++/unique_ptr.md

