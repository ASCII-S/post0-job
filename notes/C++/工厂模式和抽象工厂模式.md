---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/工厂模式和抽象工厂模式.md
related_outlines: []
---
# 工厂模式和抽象工厂模式

## 面试常见问题与标准回答

### Q: 请你描述工厂设计的流程

**标准回答：**

#### 简单工厂：

我们先有一个基类产品，比如 Product，它定义了公共接口。
然后有两个具体产品 ProductA 和 ProductB 继承它。

工厂类 Factory 负责创建这些产品，并且被实现为 单例模式（全局只有一个工厂对象，统一管理产品创建逻辑）。
在工厂里提供一个静态函数 getInstance() 获取单例，再通过 createProduct(type) 来根据传入的参数生成不同的产品。

#### 工厂方法：

核心思想：把“具体产品的创建逻辑”下放到具体的工厂子类里。

有一个 抽象工厂基类，只定义一个虚函数 createProduct()。

每个具体工厂子类只负责生产一种具体产品。

新增产品时，只需要新增一个具体工厂，不用改老工厂。

#### 抽象工厂：

核心思想：工厂不只是生产“一个产品”，而是生产“一组相关联的产品”（即产品族）。

抽象工厂定义一组接口，比如 createButton()、createTextbox()。

每个具体工厂生产一整套兼容的产品族，比如“Windows 风格控件工厂” vs “Mac 风格控件工厂”。

使用者只关心“我要哪种风格”，不需要关心内部具体类。


### Q1: 什么是工厂模式？它解决了什么问题？

**标准回答：**
工厂模式是一种创建型设计模式，它提供了一种创建对象的接口，但允许子类决定实例化哪个类。工厂模式解决的主要问题：

1. **解耦对象创建和使用**：客户端不需要知道具体类的名称
2. **封装对象创建逻辑**：将复杂的创建过程封装在工厂中
3. **便于扩展**：添加新产品时只需修改工厂，不影响客户端代码
4. **统一管理**：可以在工厂中统一处理对象的初始化、配置等

```cpp
// 传统方式的问题
class Client {
public:
    void useProduct() {
        Product* p = new ConcreteProductA();  // 强依赖具体类
        p->operation();
        delete p;
    }
};

// 工厂模式解决方案
class Client {
public:
    void useProduct() {
        Product* p = ProductFactory::createProduct("A");  // 解耦
        p->operation();
        delete p;
    }
};
```

### Q2: 简单工厂、工厂方法和抽象工厂有什么区别？

**标准回答：**

| 模式类型     | 特点                     | 使用场景               | 优缺点                           |
| ------------ | ------------------------ | ---------------------- | -------------------------------- |
| **简单工厂** | 一个工厂类创建所有产品   | 产品种类较少且相对稳定 | 简单但违反开闭原则               |
| **工厂方法** | 每个产品有对应的工厂子类 | 产品种类可能扩展       | 符合开闭原则，但类数量增加       |
| **抽象工厂** | 创建产品族，多个相关产品 | 需要创建一系列相关产品 | 支持产品族，但难以扩展新产品类型 |

```cpp
// 简单工厂：一个工厂创建所有产品
class SimpleFactory {
public:
    static Product* createProduct(const string& type) {
        if (type == "A") return new ProductA();
        if (type == "B") return new ProductB();
        return nullptr;
    }
};

// 工厂方法：每个产品有专门的工厂
class ProductAFactory : public Factory {
public:
    Product* createProduct() override {
        return new ProductA();
    }
};

// 抽象工厂：创建产品族
class ConcreteFactory1 : public AbstractFactory {
public:
    ProductA* createProductA() override { return new ProductA1(); }
    ProductB* createProductB() override { return new ProductB1(); }
};
```


### Q3: 请实现一个线程安全的单例工厂模式

**标准回答：**
结合单例模式和工厂模式，确保工厂实例唯一且线程安全：

```cpp
#include <memory>
#include <mutex>
#include <unordered_map>

class Product {
public:
    virtual ~Product() = default;
    virtual void operation() = 0;
};

class ProductA : public Product {
public:
    void operation() override {
        cout << "ProductA operation" << endl;
    }
};

class ProductB : public Product {
public:
    void operation() override {
        cout << "ProductB operation" << endl;
    }
};

class SingletonFactory {
private:
    static std::unique_ptr<SingletonFactory> instance;
    static std::mutex mutex_;
    
    // 私有构造函数
    SingletonFactory() = default;
    
public:
    // 禁用拷贝构造和赋值
    SingletonFactory(const SingletonFactory&) = delete;
    SingletonFactory& operator=(const SingletonFactory&) = delete;
    
    static SingletonFactory* getInstance() {
        std::lock_guard<std::mutex> lock(mutex_);
        if (instance == nullptr) {
            instance = std::make_unique<SingletonFactory>();
        }
        return instance.get();
    }
    
    std::unique_ptr<Product> createProduct(const std::string& type) {
        if (type == "A") {
            return std::make_unique<ProductA>();
        } else if (type == "B") {
            return std::make_unique<ProductB>();
        }
        return nullptr;
    }
};

// 静态成员定义
std::unique_ptr<SingletonFactory> SingletonFactory::instance = nullptr;
std::mutex SingletonFactory::mutex_;
```

### Q4: 如何使用模板和现代C++特性改进工厂模式？

**标准回答：**
使用C++11/14/17的现代特性可以让工厂模式更加类型安全和高效：

```cpp
#include <memory>
#include <unordered_map>
#include <functional>
#include <type_traits>

// 现代化工厂模式
template<typename BaseType>
class ModernFactory {
private:
    using CreateFunc = std::function<std::unique_ptr<BaseType>()>;
    std::unordered_map<std::string, CreateFunc> creators;
    
public:
    // 注册产品创建函数
    template<typename DerivedType>
    void registerProduct(const std::string& name) {
        static_assert(std::is_base_of_v<BaseType, DerivedType>, 
                     "DerivedType must inherit from BaseType");
        
        creators[name] = []() -> std::unique_ptr<BaseType> {
            return std::make_unique<DerivedType>();
        };
    }
    
    // 创建产品
    std::unique_ptr<BaseType> create(const std::string& name) {
        auto it = creators.find(name);
        if (it != creators.end()) {
            return it->second();
        }
        return nullptr;
    }
    
    // 支持完美转发的创建函数
    template<typename DerivedType, typename... Args>
    std::unique_ptr<BaseType> createWithArgs(Args&&... args) {
        static_assert(std::is_base_of_v<BaseType, DerivedType>, 
                     "DerivedType must inherit from BaseType");
        return std::make_unique<DerivedType>(std::forward<Args>(args)...);
    }
};

// 使用示例
void modernFactoryExample() {
    ModernFactory<Product> factory;
    
    // 注册产品
    factory.registerProduct<ProductA>("A");
    factory.registerProduct<ProductB>("B");
    
    // 创建产品
    auto productA = factory.create("A");
    auto productB = factory.createWithArgs<ProductB>();
    
    if (productA) {
        productA->operation();
    }
}
```

### Q5: 抽象工厂模式的完整实现和使用场景

**标准回答：**
抽象工厂模式用于创建相关产品族，常用于跨平台开发、UI框架等场景：

```cpp
// 抽象产品A
class AbstractProductA {
public:
    virtual ~AbstractProductA() = default;
    virtual void operationA() = 0;
};

// 抽象产品B
class AbstractProductB {
public:
    virtual ~AbstractProductB() = default;
    virtual void operationB() = 0;
    virtual void collaborate(AbstractProductA* productA) = 0;
};

// 具体产品族1
class ProductA1 : public AbstractProductA {
public:
    void operationA() override {
        cout << "ProductA1 operation" << endl;
    }
};

class ProductB1 : public AbstractProductB {
public:
    void operationB() override {
        cout << "ProductB1 operation" << endl;
    }
    
    void collaborate(AbstractProductA* productA) override {
        cout << "ProductB1 collaborates with ProductA1" << endl;
    }
};

// 具体产品族2
class ProductA2 : public AbstractProductA {
public:
    void operationA() override {
        cout << "ProductA2 operation" << endl;
    }
};

class ProductB2 : public AbstractProductB {
public:
    void operationB() override {
        cout << "ProductB2 operation" << endl;
    }
    
    void collaborate(AbstractProductA* productA) override {
        cout << "ProductB2 collaborates with ProductA2" << endl;
    }
};

// 抽象工厂
class AbstractFactory {
public:
    virtual ~AbstractFactory() = default;
    virtual std::unique_ptr<AbstractProductA> createProductA() = 0;
    virtual std::unique_ptr<AbstractProductB> createProductB() = 0;
};

// 具体工厂1
class ConcreteFactory1 : public AbstractFactory {
public:
    std::unique_ptr<AbstractProductA> createProductA() override {
        return std::make_unique<ProductA1>();
    }
    
    std::unique_ptr<AbstractProductB> createProductB() override {
        return std::make_unique<ProductB1>();
    }
};

// 具体工厂2
class ConcreteFactory2 : public AbstractFactory {
public:
    std::unique_ptr<AbstractProductA> createProductA() override {
        return std::make_unique<ProductA2>();
    }
    
    std::unique_ptr<AbstractProductB> createProductB() override {
        return std::make_unique<ProductB2>();
    }
};

// 客户端代码
class Client {
private:
    std::unique_ptr<AbstractFactory> factory;
    
public:
    Client(std::unique_ptr<AbstractFactory> f) : factory(std::move(f)) {}
    
    void run() {
        auto productA = factory->createProductA();
        auto productB = factory->createProductB();
        
        productA->operationA();
        productB->operationB();
        productB->collaborate(productA.get());
    }
};
```

### Q6: 工厂模式在实际项目中的应用场景？

**标准回答：**

1. **数据库连接工厂**：
```cpp
class DatabaseFactory {
public:
    static std::unique_ptr<Database> createDatabase(const std::string& type) {
        if (type == "MySQL") return std::make_unique<MySQLDatabase>();
        if (type == "PostgreSQL") return std::make_unique<PostgreSQLDatabase>();
        if (type == "SQLite") return std::make_unique<SQLiteDatabase>();
        return nullptr;
    }
};
```

2. **日志记录器工厂**：
```cpp
class LoggerFactory {
public:
    enum LogLevel { DEBUG, INFO, WARNING, ERROR };
    
    static std::unique_ptr<Logger> createLogger(LogLevel level) {
        switch(level) {
            case DEBUG: return std::make_unique<DebugLogger>();
            case INFO: return std::make_unique<InfoLogger>();
            case ERROR: return std::make_unique<ErrorLogger>();
            default: return std::make_unique<DefaultLogger>();
        }
    }
};
```

3. **跨平台UI组件**：
```cpp
#ifdef _WIN32
    auto factory = std::make_unique<WindowsUIFactory>();
#elif __linux__
    auto factory = std::make_unique<LinuxUIFactory>();
#elif __APPLE__
    auto factory = std::make_unique<MacUIFactory>();
#endif

auto button = factory->createButton();
auto textbox = factory->createTextBox();
```

### Q7: 工厂模式的优缺点和替代方案？

**标准回答：**

**优点**：
1. **解耦**：客户端与具体产品类解耦
2. **可扩展**：易于添加新产品类型
3. **统一管理**：集中管理对象创建逻辑
4. **符合开闭原则**：对扩展开放，对修改关闭

**缺点**：
1. **复杂性增加**：引入额外的类和接口
2. **类数量增加**：特别是工厂方法模式
3. **抽象工厂难以扩展**：添加新产品类型需要修改所有工厂

**替代方案**：
```cpp
// 1. 使用依赖注入
class Service {
    std::unique_ptr<Product> product;
public:
    Service(std::unique_ptr<Product> p) : product(std::move(p)) {}
};

// 2. 使用函数对象
auto createProductA = []() { return std::make_unique<ProductA>(); };
auto createProductB = []() { return std::make_unique<ProductB>(); };

// 3. 使用注册表模式
template<typename T>
class Registry {
    static std::unordered_map<std::string, std::function<std::unique_ptr<T>()>> creators;
public:
    template<typename U>
    static void registerCreator(const std::string& name) {
        creators[name] = []() { return std::make_unique<U>(); };
    }
    
    static std::unique_ptr<T> create(const std::string& name) {
        auto it = creators.find(name);
        return it != creators.end() ? it->second() : nullptr;
    }
};
```

## 核心要点总结

### 选择指南
- **简单工厂**：产品类型少且固定
- **工厂方法**：需要支持扩展新产品
- **抽象工厂**：需要创建产品族

### 实现要点
1. 使用智能指针管理内存
2. 考虑线程安全性
3. 利用现代C++特性提升类型安全
4. 合理使用模板减少代码重复

### 面试技巧
1. 先说明模式的目的和解决的问题
2. 对比不同变体的适用场景
3. 提供完整可编译的代码示例
4. 讨论现代C++的改进方案
5. 分析优缺点和替代方案

---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

