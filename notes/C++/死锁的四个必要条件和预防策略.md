---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/死锁的四个必要条件和预防策略.md
related_outlines: []
---
# 死锁的四个必要条件和预防策略

### 面试标准表述（精炼版）
死锁的四个条件之一是“不可剥夺条件”，指资源一旦被线程获取，除非主动释放，否则不能被强行收回。为了避免死锁，可以通过**一次性加锁、固定顺序加锁、`try_lock` + 重试机制**等方法来打破这个条件，从而降低死锁发生的可能性。

---

### 死锁的四个必要条件（Coffman 条件）

1. **互斥（Mutual Exclusion）**

   * 至少有一个资源不能被多个线程同时使用。

2. **占有且等待（Hold and Wait）**

   * 线程已经持有一个资源，还要继续申请其他资源。

3. **不可剥夺（No Preemption）**

   * 线程获得的资源在释放之前不能被强行剥夺，只能线程自己释放。
   * 这就是你说的“静态条件”。

4. **环路等待（Circular Wait）**

   * 存在一个循环等待资源的链条。

当这四个条件同时满足时，就可能产生死锁。

---

### 如何避免“不可剥夺条件”

C++ 标准库的锁（`std::mutex`）就是典型的“不可剥夺资源”：锁一旦拿到，就必须自己 unlock，别的线程抢不走。避免死锁可以考虑：

1. **一次性申请所有资源**

   * 避免“占有且等待”。C++ 里有 `std::lock(m1, m2)`，能一次性尝试加多个锁。

2. **资源有序分配**

   * 规定所有线程按相同顺序加锁，打破“环路等待”。

3. **使用 `try_lock`**

   * 如果没拿到锁，就释放已有资源，稍后再试，这样相当于允许“剥夺”。

4. **更高级工具**

   * 用 `std::scoped_lock`（C++17），它能同时锁多个 mutex 并避免死锁。
   * 使用无锁数据结构（lock-free）或原子操作，尽量减少锁竞争。

---

---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

