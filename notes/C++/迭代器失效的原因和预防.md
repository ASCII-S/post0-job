---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/迭代器失效的原因和预防.md
related_outlines: []
---
# 迭代器失效的原因和预防

## 面试标准答案（可背诵）

迭代器失效是指容器在插入、删除等修改操作后，原有迭代器可能指向无效内存或错误位置的现象。主要原因有三类：**内存重新分配**（如vector扩容）、**元素位置改变**（如删除操作）、**容器内部结构变化**（如rehash）。预防方法包括：使用容器返回的新迭代器、避免在遍历时修改容器、使用erase的返回值更新迭代器、或改用索引访问。不同容器失效规则不同：vector和deque在插入删除时最易失效，list和关联容器相对安全。

---

## 一、迭代器失效的本质原因

### 1.1 什么是迭代器失效

迭代器失效是指迭代器所指向的元素或位置因容器的修改操作而变得不可访问或不正确。使用失效的迭代器会导致：
- **未定义行为**（访问野指针）
- **程序崩溃**
- **数据错误**

### 1.2 迭代器失效的三大原因

#### 原因1：内存重新分配
```cpp
std::vector<int> vec = {1, 2, 3};
auto it = vec.begin();
vec.push_back(4);  // 可能触发扩容，导致内存重新分配
// it 此时可能失效，指向已释放的内存
```

**机制**：vector等动态数组在容量不足时会：
1. 分配更大的新内存
2. 拷贝/移动元素到新内存
3. 释放旧内存
4. 旧迭代器仍指向已释放的旧内存 → 失效

#### 原因2：元素位置改变
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
auto it = vec.begin() + 2;  // 指向3
vec.erase(vec.begin());      // 删除1
// it 仍指向相同的内存位置，但现在是4而不是3
```

**机制**：删除或插入元素后，后续元素会移动，导致迭代器指向错误的元素。

#### 原因3：容器内部结构重组
```cpp
std::unordered_map<int, int> umap;
auto it = umap.begin();
// 大量插入操作触发rehash
for (int i = 0; i < 1000; ++i) {
    umap[i] = i;  // 可能触发rehash
}
// it 可能失效，因为哈希表重新组织
```

**机制**：哈希表rehash时会重新分配桶并重新插入所有元素。

---

## 二、各容器的迭代器失效规则

### 2.1 顺序容器

#### vector

| 操作                     | 迭代器失效情况                                             |
| ------------------------ | ---------------------------------------------------------- |
| `push_back/emplace_back` | 若扩容：**全部失效**<br>若未扩容：**end()失效**，其他有效  |
| `insert`                 | 若扩容：**全部失效**<br>若未扩容：**插入点及之后**全部失效 |
| `erase`                  | **删除点及之后**全部失效，返回下一个有效迭代器             |
| `clear`                  | **全部失效**                                               |

```cpp
// 错误示例
std::vector<int> vec = {1, 2, 3, 4, 5};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    if (*it == 3) {
        vec.erase(it);  // it失效！继续使用会崩溃
    }
}

// 正确做法
for (auto it = vec.begin(); it != vec.end(); ) {
    if (*it == 3) {
        it = vec.erase(it);  // erase返回下一个有效迭代器
    } else {
        ++it;
    }
}
```

#### deque

| 操作                   | 迭代器失效情况                                  |
| ---------------------- | ----------------------------------------------- |
| `push_back/push_front` | 所有迭代器失效，但引用和指针仍有效（除了end()） |
| `insert`               | **全部失效**                                    |
| `erase`                | **删除点及之后**失效                            |
| 首尾删除               | 仅被删除元素的迭代器失效                        |

#### list / forward_list

| 操作     | 迭代器失效情况                                     |
| -------- | -------------------------------------------------- |
| `insert` | **不影响**任何迭代器                               |
| `erase`  | **仅被删除元素**的迭代器失效                       |
| `splice` | **不影响**任何迭代器（迭代器仍有效，但指向新容器） |

```cpp
std::list<int> lst = {1, 2, 3, 4, 5};
for (auto it = lst.begin(); it != lst.end(); ) {
    if (*it == 3) {
        it = lst.erase(it);  // 仅删除元素的迭代器失效
    } else {
        ++it;
    }
}
```

**优势**：链表不涉及元素移动，插入删除不影响其他元素。

### 2.2 关联容器

#### map / set / multimap / multiset

| 操作     | 迭代器失效情况               |
| -------- | ---------------------------- |
| `insert` | **不影响**任何迭代器         |
| `erase`  | **仅被删除元素**的迭代器失效 |
| `clear`  | **全部失效**                 |

```cpp
std::map<int, std::string> m = {{1, "a"}, {2, "b"}, {3, "c"}};
for (auto it = m.begin(); it != m.end(); ) {
    if (it->first == 2) {
        it = m.erase(it);  // C++11后erase返回下一个迭代器
    } else {
        ++it;
    }
}
```

**特点**：红黑树实现，插入删除只影响被操作节点。

#### unordered_map / unordered_set

| 操作             | 迭代器失效情况                         |
| ---------------- | -------------------------------------- |
| `insert`         | 若rehash：**全部失效**<br>否则：不影响 |
| `erase`          | **仅被删除元素**失效                   |
| `rehash/reserve` | **全部失效**                           |

```cpp
std::unordered_set<int> uset = {1, 2, 3};
auto it = uset.begin();

// 可能触发rehash
uset.insert(4);
// it 可能失效！

// 预防：预留空间避免rehash
uset.reserve(100);
```

---

## 三、迭代器失效的预防策略

### 3.1 使用容器返回的新迭代器

**核心原则**：C++11后，`erase()`和`insert()`都返回新的有效迭代器。

```cpp
// erase返回下一个有效迭代器
std::vector<int> vec = {1, 2, 3, 4, 5};
for (auto it = vec.begin(); it != vec.end(); ) {
    if (*it % 2 == 0) {
        it = vec.erase(it);  // ✅ 更新为返回的迭代器
    } else {
        ++it;
    }
}

// insert返回指向新插入元素的迭代器
auto it = vec.begin();
it = vec.insert(it, 100);  // ✅ it现在指向新插入的100
```

### 3.2 使用erase-remove惯用法

**适用场景**：删除满足条件的所有元素（vector/deque等）。

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 2, 3};

// erase-remove惯用法：一步到位，避免迭代器失效问题
vec.erase(
    std::remove_if(vec.begin(), vec.end(), 
        [](int x) { return x % 2 == 0; }),
    vec.end()
);
// 结果: {1, 3, 5, 3}
```

**原理**：
1. `remove_if`将不删除的元素移到前面，返回新的逻辑末尾
2. `erase`一次性删除逻辑末尾到实际末尾的元素

### 3.3 使用索引而非迭代器

**适用容器**：vector、deque等支持随机访问的容器。

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 从后向前遍历，避免索引偏移问题
for (int i = vec.size() - 1; i >= 0; --i) {
    if (vec[i] % 2 == 0) {
        vec.erase(vec.begin() + i);
    }
}

// 或者正向遍历但调整索引
for (size_t i = 0; i < vec.size(); ) {
    if (vec[i] % 2 == 0) {
        vec.erase(vec.begin() + i);
        // 不递增i，因为后续元素前移
    } else {
        ++i;
    }
}
```

### 3.4 避免在遍历时修改容器

**最佳实践**：分离读写操作。

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
std::vector<int> to_remove;

// 阶段1：收集要删除的元素
for (auto it = vec.begin(); it != vec.end(); ++it) {
    if (*it % 2 == 0) {
        to_remove.push_back(*it);
    }
}

// 阶段2：批量删除
for (int val : to_remove) {
    vec.erase(std::remove(vec.begin(), vec.end(), val), vec.end());
}
```

### 3.5 预分配空间（针对vector）

```cpp
std::vector<int> vec;
vec.reserve(1000);  // 预留空间，避免扩容导致的迭代器失效

auto it = vec.begin();
for (int i = 0; i < 100; ++i) {
    vec.push_back(i);  // 不会扩容，it仍然有效（但可能不指向预期元素）
}
```

**注意**：即使不扩容，`push_back`也会使`end()`失效。

### 3.6 使用智能迭代器模式

对于复杂场景，可以封装迭代器逻辑：

```cpp
template<typename Container>
void safe_erase_if(Container& c, auto predicate) {
    for (auto it = c.begin(); it != c.end(); ) {
        if (predicate(*it)) {
            it = c.erase(it);
        } else {
            ++it;
        }
    }
}

// 使用
std::vector<int> vec = {1, 2, 3, 4, 5};
safe_erase_if(vec, [](int x) { return x % 2 == 0; });
```

---

## 四、常见陷阱与调试技巧

### 4.1 常见错误模式

#### 错误1：在range-based for中修改容器
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
for (int x : vec) {
    if (x == 3) {
        vec.erase(std::find(vec.begin(), vec.end(), x));  // ❌ 危险！
    }
}
// 问题：range-based for内部使用迭代器，修改容器会导致未定义行为
```

#### 错误2：保存end()迭代器
```cpp
std::vector<int> vec = {1, 2, 3};
auto end_it = vec.end();  // 保存end迭代器
vec.push_back(4);         // end_it失效
if (vec.begin() != end_it) {  // ❌ 使用失效的迭代器
    // ...
}
```

**正确做法**：每次都重新获取`end()`。

#### 错误3：多线程环境下的迭代器
```cpp
std::vector<int> vec = {1, 2, 3};
auto it = vec.begin();

// 线程1
for (auto it = vec.begin(); it != vec.end(); ++it) {
    // 读取
}

// 线程2
vec.push_back(4);  // ❌ 线程1的迭代器失效
```

**解决**：使用互斥锁保护或使用线程安全容器。

### 4.2 调试技巧

#### 使用调试模式
```cpp
// GCC/Clang: 编译时启用调试模式
// g++ -D_GLIBCXX_DEBUG program.cpp

// MSVC: 默认在Debug模式下检测迭代器失效
```

调试模式会检测：
- 使用失效的迭代器
- 不同容器的迭代器比较
- 越界访问

#### 使用断言验证
```cpp
std::vector<int> vec = {1, 2, 3};
auto it = vec.begin();
size_t original_capacity = vec.capacity();

vec.push_back(4);

assert(vec.capacity() == original_capacity && "容器扩容，迭代器可能失效");
```

---

## 五、实战案例

### 案例1：安全删除vector中的偶数
```cpp
void remove_even_numbers(std::vector<int>& vec) {
    // 方法1：erase-remove惯用法（推荐）
    vec.erase(
        std::remove_if(vec.begin(), vec.end(),
            [](int x) { return x % 2 == 0; }),
        vec.end()
    );
    
    // 方法2：使用erase返回值
    // for (auto it = vec.begin(); it != vec.end(); ) {
    //     if (*it % 2 == 0) {
    //         it = vec.erase(it);
    //     } else {
    //         ++it;
    //     }
    // }
    
    // 方法3：从后向前删除
    // for (int i = vec.size() - 1; i >= 0; --i) {
    //     if (vec[i] % 2 == 0) {
    //         vec.erase(vec.begin() + i);
    //     }
    // }
}
```

### 案例2：安全遍历并修改map
```cpp
void remove_negative_values(std::map<int, int>& m) {
    for (auto it = m.begin(); it != m.end(); ) {
        if (it->second < 0) {
            it = m.erase(it);  // C++11返回下一个迭代器
        } else {
            ++it;
        }
    }
}

// C++20：使用std::erase_if（更简洁）
void remove_negative_values_cpp20(std::map<int, int>& m) {
    std::erase_if(m, [](const auto& pair) {
        return pair.second < 0;
    });
}
```

### 案例3：list的splice操作
```cpp
std::list<int> list1 = {1, 2, 3};
std::list<int> list2 = {4, 5, 6};

auto it = list2.begin();
list1.splice(list1.end(), list2, it);  // 将list2的第一个元素移到list1

// it仍然有效，但现在指向list1中的元素！
std::cout << *it;  // 输出4，it仍可用
```

---

## 六、总结与最佳实践

### 核心要点

1. **了解容器特性**：不同容器失效规则不同
   - vector/deque：最容易失效
   - list：最安全，仅删除元素失效
   - map/set：仅删除元素失效
   - unordered_*：rehash时全部失效

2. **使用现代C++特性**：
   - C++11：`erase()`返回迭代器
   - C++20：`std::erase_if()`统一接口

3. **优先级策略**：
   ```
   首选：std::erase_if (C++20)
   次选：erase-remove惯用法
   再选：使用erase返回值
   最后：手动管理索引
   ```

### 检查清单

遍历容器时自问：
- [ ] 是否在循环中调用了`insert/erase/push_back`？
- [ ] 是否保存了`end()`迭代器？
- [ ] 是否使用了range-based for但修改了容器？
- [ ] vector是否可能扩容？
- [ ] unordered容器是否可能rehash？
- [ ] 多线程环境下是否有竞争？

### 推荐做法

```cpp
// ✅ 推荐：erase-remove
vec.erase(std::remove_if(vec.begin(), vec.end(), pred), vec.end());

// ✅ 推荐：使用返回值
for (auto it = vec.begin(); it != vec.end(); ) {
    if (condition) {
        it = vec.erase(it);
    } else {
        ++it;
    }
}

// ✅ 推荐：C++20
std::erase_if(vec, pred);

// ❌ 避免：忽略返回值
for (auto it = vec.begin(); it != vec.end(); ++it) {
    vec.erase(it);  // 迭代器失效！
}
```

---

## 参考资源

- C++ Primer (5th Edition) - 第9章：顺序容器
- Effective STL - 条款9：慎重选择删除元素的方法
- cppreference.com - Iterator invalidation rules


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

