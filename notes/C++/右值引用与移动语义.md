---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/右值引用与移动语义.md
related_outlines: []
---
# 右值引用与移动语义

## 面试标准答案（可背诵)

**右值引用**（`T&&`）是 C++11 引入的新特性，用于绑定右值（临时对象）。**移动语义**是利用右值引用实现的一种优化机制，通过"窃取"临时对象的资源而非深拷贝，大幅提升性能。

核心要点：
1. **右值引用**提供了区分临时对象的能力
2. **移动语义**通过移动构造函数和移动赋值运算符实现资源转移
3. **std::move** 将左值转换为右值引用，显式触发移动
4. 移动后对象处于有效但未指定状态，移动操作应标记为 `noexcept`

---

## 详细讲解

### 1. 问题背景：为什么需要移动语义？

#### 1.1 传统拷贝的性能问题

在 C++11 之前，对象传递和返回只能通过拷贝：

```cpp
class Buffer {
    char* data;
    size_t size;
public:
    Buffer(size_t s) : size(s), data(new char[s]) {}
    
    // 拷贝构造函数
    Buffer(const Buffer& other) : size(other.size) {
        data = new char[size];
        std::memcpy(data, other.data, size);  // 深拷贝，开销大
        std::cout << "拷贝构造，分配 " << size << " 字节\n";
    }
    
    ~Buffer() { delete[] data; }
};

Buffer createBuffer() {
    Buffer temp(1024 * 1024);  // 1MB
    return temp;               // 返回时需要拷贝
}

int main() {
    Buffer buf = createBuffer();  // 拷贝 1MB 数据！
}
```

**问题**：临时对象 `temp` 马上就要销毁，但还要花费时间深拷贝，浪费资源。

#### 1.2 移动语义的解决方案

如果能"偷走"临时对象的资源，而不是拷贝，性能会大幅提升：

```cpp
class Buffer {
    char* data;
    size_t size;
public:
    // 移动构造函数（接受右值引用）
    Buffer(Buffer&& other) noexcept 
        : data(other.data), size(other.size) {
        other.data = nullptr;  // 源对象置空
        other.size = 0;
        std::cout << "移动构造，仅转移指针\n";
    }
};

// 现在 createBuffer() 返回时会调用移动构造，几乎零开销！
```

### 2. 右值引用的语法和特性

#### 2.1 基本语法

```cpp
int&& rref = 42;              // 右值引用绑定字面量
int&& rref2 = 10 + 20;        // 绑定临时计算结果

std::string&& s = std::string("temp");  // 绑定临时对象

int x = 5;
// int&& r = x;               // ❌ 错误：不能绑定左值
int&& r = std::move(x);       // ✅ std::move 转换为右值
```

#### 2.2 核心特性：具名右值引用是左值

```cpp
void process(std::string&& s) {
    // s 的类型是 std::string&&（右值引用）
    // 但 s 本身是左值（有名字、可取地址）
    
    std::string s1 = s;             // 调用拷贝构造（s 是左值）
    std::string s2 = std::move(s);  // 调用移动构造（显式转换）
}
```

### 3. 移动语义的实现

#### 3.1 移动构造函数

```cpp
class String {
    char* data;
    size_t length;
    
public:
    // 普通构造
    String(const char* str) {
        length = std::strlen(str);
        data = new char[length + 1];
        std::strcpy(data, str);
    }
    
    // 拷贝构造（左值）
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        std::strcpy(data, other.data);
        std::cout << "拷贝构造\n";
    }
    
    // 移动构造（右值）
    String(String&& other) noexcept {
        data = other.data;       // 直接接管指针
        length = other.length;
        
        other.data = nullptr;    // 源对象置空，防止析构时释放
        other.length = 0;
        std::cout << "移动构造\n";
    }
    
    ~String() {
        delete[] data;
    }
};
```

**关键点**：
- 参数类型为 `String&&`
- 标记为 `noexcept`（重要！）
- 转移资源后将源对象置为有效状态

#### 3.2 移动赋值运算符

```cpp
class String {
public:
    // 移动赋值
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            // 1. 释放自己的资源
            delete[] data;
            
            // 2. 接管对方的资源
            data = other.data;
            length = other.length;
            
            // 3. 将对方置空
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }
};
```

#### 3.3 五法则（Rule of Five）

如果你定义了以下任何一个，通常需要定义全部五个：

```cpp
class Resource {
public:
    Resource();                              // 构造函数
    ~Resource();                             // 析构函数
    Resource(const Resource&);               // 拷贝构造
    Resource& operator=(const Resource&);    // 拷贝赋值
    Resource(Resource&&) noexcept;           // 移动构造
    Resource& operator=(Resource&&) noexcept;// 移动赋值
};
```

**或者使用零法则**：让编译器自动生成（如果成员都支持移动）：

```cpp
class Widget {
    std::string name;
    std::vector<int> data;
    // 编译器会自动生成高效的移动构造和移动赋值
};
```

### 4. std::move 的作用

#### 4.1 什么是 std::move

`std::move` 是一个类型转换工具，将左值转换为右值引用：

```cpp
template<typename T>
typename remove_reference<T>::type&& move(T&& arg) noexcept {
    return static_cast<typename remove_reference<T>::type&&>(arg);
}
```

**本质**：`std::move` 只做类型转换，不移动任何东西！

```cpp
std::string s1 = "hello";
std::string s2 = std::move(s1);  // std::move 将 s1 转为右值引用

// 等价于：
std::string s2 = static_cast<std::string&&>(s1);
```

#### 4.2 使用场景

```cpp
std::vector<std::string> vec;
std::string str = "hello";

// 场景1：显式移动已有对象
vec.push_back(std::move(str));  // str 被移动，之后为空

// 场景2：函数返回局部变量时，不要用 std::move
std::string createString() {
    std::string local = "test";
    return local;        // ✅ 编译器自动优化（RVO 或移动）
    // return std::move(local);  // ❌ 反而阻止 RVO 优化
}

// 场景3：转移unique_ptr所有权
std::unique_ptr<int> p1 = std::make_unique<int>(42);
std::unique_ptr<int> p2 = std::move(p1);  // p1 变为空
```

### 5. 实际应用案例

#### 案例1：std::vector 的优化

```cpp
std::vector<String> vec;

String s1("hello");
vec.push_back(s1);              // 拷贝构造
vec.push_back(String("world")); // 移动构造（临时对象）
vec.push_back(std::move(s1));   // 移动构造（显式移动）
```

#### 案例2：智能指针的所有权转移

```cpp
std::unique_ptr<Widget> factory() {
    auto ptr = std::make_unique<Widget>();
    return ptr;  // 自动移动，无拷贝
}

void consume(std::unique_ptr<Widget> ptr) {
    // 接管所有权
}

auto p = factory();
consume(std::move(p));  // 转移所有权，p 变为空
```

#### 案例3：swap 的高效实现

```cpp
template<typename T>
void swap(T& a, T& b) {
    T temp = std::move(a);    // 移动而非拷贝
    a = std::move(b);
    b = std::move(temp);
}

// 对于大对象（如 std::vector），性能提升显著
```

#### 案例4：容器的 emplace 操作

```cpp
std::vector<std::pair<std::string, int>> vec;

// 传统方式：构造临时对象，然后移动
vec.push_back(std::make_pair("key", 42));

// emplace：直接在容器中构造，避免移动
vec.emplace_back("key", 42);  // 完美转发参数

// emplace_back 的简化实现
template<typename... Args>
void emplace_back(Args&&... args) {
    new (ptr) T(std::forward<Args>(args)...);  // 原地构造
}
```

### 6. 移动语义的注意事项

#### 6.1 移动后对象的状态

标准规定：移动后的对象处于**有效但未指定**（valid but unspecified）状态。

```cpp
std::string s1 = "hello";
std::string s2 = std::move(s1);

// s1 的状态：
// ✅ 有效：可以重新赋值、销毁
// ❌ 未指定：内容不确定，不应使用

s1 = "new value";  // ✅ 可以重新赋值
s1.clear();        // ✅ 可以调用成员函数
// std::cout << s1;  // ⚠️ 不推荐，内容未指定
```

#### 6.2 noexcept 的重要性

移动操作应标记为 `noexcept`，原因：

```cpp
class Widget {
public:
    Widget(Widget&&) noexcept;  // 必须 noexcept
};

std::vector<Widget> vec;
vec.push_back(Widget());

// std::vector 重新分配内存时：
// - 如果移动构造是 noexcept，使用移动
// - 否则为了异常安全，使用拷贝（性能差）
```

#### 6.3 不要返回局部变量的右值引用

```cpp
String&& bad() {
    String local("temp");
    return std::move(local);  // ❌ 危险：返回悬空引用
}  // local 被销毁

String good() {
    String local("temp");
    return local;  // ✅ 编译器会自动优化（RVO 或移动）
}
```

#### 6.4 const 对象无法移动

```cpp
const std::string s1 = "hello";
std::string s2 = std::move(s1);  // 仍然是拷贝！

// std::move(s1) 的类型是 const std::string&&
// 移动构造签名是 String(String&&)，不匹配
// 退化为拷贝构造 String(const String&)
```

### 7. 移动语义与完美转发

右值引用还支持完美转发（Perfect Forwarding）：

```cpp
template<typename T>
void wrapper(T&& arg) {
    // 万能引用（Universal Reference）
    process(std::forward<T>(arg));  // 保持 arg 的值类别
}

int x = 10;
wrapper(x);    // T 推导为 int&，转发左值
wrapper(42);   // T 推导为 int，转发右值
```

### 8. 性能对比

```cpp
#include <chrono>
#include <vector>

class BigObject {
    std::vector<int> data;
public:
    BigObject() : data(1000000) {}
    
    // 拷贝构造
    BigObject(const BigObject& other) : data(other.data) {
        std::cout << "拷贝\n";
    }
    
    // 移动构造
    BigObject(BigObject&& other) noexcept : data(std::move(other.data)) {
        std::cout << "移动\n";
    }
};

// 测试
std::vector<BigObject> vec;

// 拷贝方式（C++03）
BigObject obj;
vec.push_back(obj);  // 拷贝 1,000,000 个整数

// 移动方式（C++11）
vec.push_back(std::move(obj));  // 只转移 3 个指针（vector 内部实现）
```

**性能差异**：对于大对象，移动可能比拷贝快几十到几百倍。

---

## 总结

### 核心概念
1. **右值引用** (`T&&`)：绑定临时对象的引用类型
2. **移动语义**：通过转移资源而非拷贝来优化性能
3. **std::move**：将左值转换为右值引用的类型转换工具

### 关键要点
- 右值引用变量本身是左值
- 移动构造/赋值应标记为 `noexcept`
- 移动后对象处于有效但未指定状态
- 不要对返回值使用 `std::move`（会阻止 RVO）
- const 对象无法移动

### 适用场景
- 管理资源的类（RAII）
- 容器操作
- 智能指针所有权转移
- 性能关键的代码路径

### 最佳实践
- 遵循五法则或零法则
- 优先使用标准库容器（已实现移动语义）
- 合理使用 `std::move`，避免过度使用
- 使用 `emplace` 系列函数提升效率


---

## 相关笔记
<!-- 自动生成 -->

- [移动语义和std::move](notes/C++/移动语义和std::move.md) - 相似度: 39% | 标签: C++, C++/移动语义和std::move.md
- [右值引用](notes/C++/右值引用.md) - 相似度: 36% | 标签: C++, C++/右值引用.md

