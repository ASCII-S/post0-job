---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/深拷贝和浅拷贝的区别，什么时候需要深拷贝？.md
related_outlines: []
---
## 标准答案（可背诵）

**浅拷贝**：只复制对象的成员变量值，如果成员变量是指针，则复制指针值（地址），两个对象指向同一块内存。

**深拷贝**：不仅复制成员变量值，还复制指针指向的内容，为每个对象分配独立的内存空间。

**什么时候需要深拷贝**：
1. 类中有**指针成员变量**且指向动态分配的内存
2. 类中有**资源管理**（文件句柄、网络连接等）
3. 需要**独立的对象状态**，避免多个对象共享同一资源
4. 实现**拷贝构造函数**和**赋值运算符**时

**核心原则**：如果浅拷贝会导致多个对象共享同一资源，就需要深拷贝。

---

## 详细讲解

### 1. 浅拷贝（Shallow Copy）

#### 1.1 基本概念

浅拷贝只复制对象的基本成员变量，对于指针成员，只复制指针的值（地址），不复制指针指向的内容。

```cpp
class ShallowCopy {
private:
    int* data;
    int size;
public:
    ShallowCopy(int s) : size(s) {
        data = new int[size];
        for (int i = 0; i < size; ++i) {
            data[i] = i;
        }
    }
    
    // 浅拷贝：编译器默认生成的拷贝构造函数
    ShallowCopy(const ShallowCopy& other) 
        : data(other.data), size(other.size) {
        // 只复制了指针值，两个对象指向同一块内存
    }
    
    ~ShallowCopy() {
        delete[] data;
    }
    
    void print() {
        for (int i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};
```

#### 1.2 浅拷贝的问题

```cpp
void demonstrateShallowCopyProblem() {
    ShallowCopy obj1(5);
    ShallowCopy obj2 = obj1;  // 浅拷贝
    
    // 修改obj2的内容
    obj2.data[0] = 999;
    
    obj1.print();  // 输出：999 1 2 3 4
    obj2.print();  // 输出：999 1 2 3 4
    
    // 问题：obj1也被修改了！
    
    // 更严重的问题：析构时double free
    // obj1析构时delete[] data
    // obj2析构时又delete[] data（同一块内存）
    // 导致程序崩溃！
}
```

#### 1.3 浅拷贝的适用场景

浅拷贝适用于没有动态分配资源的简单类：

```cpp
class SimpleClass {
private:
    int value;
    double rate;
    std::string name;  // string内部管理内存，浅拷贝是安全的
public:
    SimpleClass(int v, double r, const std::string& n) 
        : value(v), rate(r), name(n) {}
    
    // 编译器生成的浅拷贝就足够了
    // 因为所有成员都是值类型或自管理内存的类型
};
```

---

### 2. 深拷贝（Deep Copy）

#### 2.1 基本概念

深拷贝不仅复制成员变量，还复制指针指向的内容，为每个对象分配独立的内存空间。

```cpp
class DeepCopy {
private:
    int* data;
    int size;
public:
    DeepCopy(int s) : size(s) {
        data = new int[size];
        for (int i = 0; i < size; ++i) {
            data[i] = i;
        }
    }
    
    // 深拷贝：复制指针指向的内容
    DeepCopy(const DeepCopy& other) : size(other.size) {
        data = new int[size];  // 分配新内存
        for (int i = 0; i < size; ++i) {
            data[i] = other.data[i];  // 复制内容
        }
    }
    
    // 深拷贝赋值运算符
    DeepCopy& operator=(const DeepCopy& other) {
        if (this != &other) {  // 防止自赋值
            delete[] data;     // 释放原有内存
            
            size = other.size;
            data = new int[size];  // 分配新内存
            for (int i = 0; i < size; ++i) {
                data[i] = other.data[i];  // 复制内容
            }
        }
        return *this;
    }
    
    ~DeepCopy() {
        delete[] data;
    }
    
    void print() {
        for (int i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};
```

#### 2.2 深拷贝的优势

```cpp
void demonstrateDeepCopyAdvantage() {
    DeepCopy obj1(5);
    DeepCopy obj2 = obj1;  // 深拷贝
    
    // 修改obj2的内容
    obj2.data[0] = 999;
    
    obj1.print();  // 输出：0 1 2 3 4（不受影响）
    obj2.print();  // 输出：999 1 2 3 4
    
    // 安全：两个对象有独立的内存空间
    // 析构时不会出现double free问题
}
```

---

### 3. 什么时候需要深拷贝？

#### 3.1 有指针成员且指向动态分配内存

```cpp
class String {
private:
    char* str;
    size_t length;
public:
    String(const char* s) {
        length = strlen(s);
        str = new char[length + 1];
        strcpy(str, s);
    }
    
    // 必须深拷贝
    String(const String& other) : length(other.length) {
        str = new char[length + 1];
        strcpy(str, other.str);
    }
    
    String& operator=(const String& other) {
        if (this != &other) {
            delete[] str;
            length = other.length;
            str = new char[length + 1];
            strcpy(str, other.str);
        }
        return *this;
    }
    
    ~String() {
        delete[] str;
    }
};
```

#### 3.2 有资源管理需求

```cpp
class FileManager {
private:
    FILE* file;
    std::string filename;
public:
    FileManager(const std::string& name) : filename(name) {
        file = fopen(name.c_str(), "r");
    }
    
    // 需要深拷贝：每个对象管理独立的文件句柄
    FileManager(const FileManager& other) : filename(other.filename) {
        file = fopen(filename.c_str(), "r");
    }
    
    ~FileManager() {
        if (file) {
            fclose(file);
        }
    }
};
```

#### 3.3 需要独立对象状态

```cpp
class Counter {
private:
    int* count;  // 共享计数器
    static int totalCount;
public:
    Counter() {
        count = &totalCount;
        (*count)++;
    }
    
    // 浅拷贝：多个对象共享同一个计数器
    // 深拷贝：每个对象有独立的计数器
    Counter(const Counter& other) {
        count = new int(1);  // 深拷贝：独立计数器
    }
    
    ~Counter() {
        if (count != &totalCount) {
            delete count;
        }
    }
};
```

---

### 4. 三法则（Rule of Three）

#### 4.1 基本概念

如果一个类需要自定义以下三个函数之一，通常需要自定义所有三个：
1. 析构函数
2. 拷贝构造函数
3. 赋值运算符

```cpp
class RuleOfThree {
private:
    int* data;
    size_t size;
public:
    // 1. 构造函数
    RuleOfThree(size_t s) : size(s) {
        data = new int[size];
    }
    
    // 2. 析构函数
    ~RuleOfThree() {
        delete[] data;
    }
    
    // 3. 拷贝构造函数
    RuleOfThree(const RuleOfThree& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }
    
    // 4. 赋值运算符
    RuleOfThree& operator=(const RuleOfThree& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new int[size];
            std::copy(other.data, other.data + size, data);
        }
        return *this;
    }
};
```

#### 4.2 五法则（Rule of Five）- C++11

C++11引入移动语义后，增加了两个函数：

```cpp
class RuleOfFive {
private:
    int* data;
    size_t size;
public:
    // 1. 构造函数
    RuleOfFive(size_t s) : size(s) {
        data = new int[size];
    }
    
    // 2. 析构函数
    ~RuleOfFive() {
        delete[] data;
    }
    
    // 3. 拷贝构造函数
    RuleOfFive(const RuleOfFive& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }
    
    // 4. 赋值运算符
    RuleOfFive& operator=(const RuleOfFive& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new int[size];
            std::copy(other.data, other.data + size, data);
        }
        return *this;
    }
    
    // 5. 移动构造函数
    RuleOfFive(RuleOfFive&& other) noexcept 
        : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
    
    // 6. 移动赋值运算符
    RuleOfFive& operator=(RuleOfFive&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }
};
```

---

### 5. 现代C++的解决方案

#### 5.1 使用智能指针

```cpp
#include <memory>

class ModernClass {
private:
    std::unique_ptr<int[]> data;
    size_t size;
public:
    ModernClass(size_t s) : size(s) {
        data = std::make_unique<int[]>(size);
    }
    
    // 不需要自定义拷贝构造函数和赋值运算符
    // unique_ptr会自动处理深拷贝
    ModernClass(const ModernClass& other) : size(other.size) {
        data = std::make_unique<int[]>(size);
        std::copy(other.data.get(), other.data.get() + size, data.get());
    }
    
    // 移动语义自动支持
    ModernClass(ModernClass&&) = default;
    ModernClass& operator=(ModernClass&&) = default;
};
```

#### 5.2 使用RAII和STL容器

```cpp
class ModernString {
private:
    std::string str;  // STL容器自动管理内存
public:
    ModernString(const char* s) : str(s) {}
    
    // 编译器生成的拷贝构造函数就足够了
    // std::string会自动进行深拷贝
    
    void print() const {
        std::cout << str << std::endl;
    }
};
```

#### 5.3 使用零法则（Rule of Zero）

```cpp
class ZeroRule {
private:
    std::vector<int> data;        // 自动管理内存
    std::unique_ptr<int> ptr;     // 智能指针
    std::string name;             // 自动管理内存
public:
    ZeroRule(std::vector<int> d, std::string n) 
        : data(std::move(d)), name(std::move(n)) {
        ptr = std::make_unique<int>(42);
    }
    
    // 不需要自定义任何特殊成员函数
    // 编译器生成的版本就足够了
    // 所有成员都会自动进行正确的拷贝/移动
};
```

---

### 6. 深拷贝的实现技巧

#### 6.1 异常安全的深拷贝

```cpp
class ExceptionSafeCopy {
private:
    int* data;
    size_t size;
public:
    ExceptionSafeCopy(const ExceptionSafeCopy& other) : size(other.size) {
        data = new(std::nothrow) int[size];
        if (!data) {
            throw std::bad_alloc();
        }
        
        try {
            std::copy(other.data, other.data + size, data);
        } catch (...) {
            delete[] data;
            throw;
        }
    }
    
    ExceptionSafeCopy& operator=(const ExceptionSafeCopy& other) {
        if (this != &other) {
            // 创建临时对象（异常安全）
            ExceptionSafeCopy temp(other);
            swap(temp);
        }
        return *this;
    }
    
private:
    void swap(ExceptionSafeCopy& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
};
```

#### 6.2 使用copy-and-swap惯用法

```cpp
class CopyAndSwap {
private:
    int* data;
    size_t size;
public:
    CopyAndSwap& operator=(const CopyAndSwap& other) {
        CopyAndSwap temp(other);  // 创建副本
        swap(temp);               // 交换内容
        return *this;            // temp析构时自动清理
    }
    
    CopyAndSwap& operator=(CopyAndSwap&& other) noexcept {
        swap(other);
        return *this;
    }
    
private:
    void swap(CopyAndSwap& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
};
```

---

### 7. 常见面试延伸问题

#### 7.1 什么时候不需要深拷贝？

```cpp
// 1. 只有值类型成员
class ValueOnly {
    int x, y;
    double value;
    // 编译器生成的浅拷贝就足够了
};

// 2. 成员都是自管理内存的类型
class SelfManaged {
    std::string name;
    std::vector<int> data;
    // 这些类型内部已经实现了深拷贝
};

// 3. 单例模式
class Singleton {
private:
    static Singleton* instance;
    Singleton() = default;
public:
    Singleton(const Singleton&) = delete;  // 禁止拷贝
    Singleton& operator=(const Singleton&) = delete;
};
```

#### 7.2 深拷贝的性能考虑

```cpp
class PerformanceConsideration {
private:
    std::vector<int> largeData;
public:
    // 深拷贝可能很昂贵
    PerformanceConsideration(const PerformanceConsideration& other) 
        : largeData(other.largeData) {  // 深拷贝整个vector
    }
    
    // 考虑使用移动语义
    PerformanceConsideration(PerformanceConsideration&& other) noexcept
        : largeData(std::move(other.largeData)) {  // 移动，不拷贝
    }
};
```

#### 7.3 深拷贝 vs 引用计数

```cpp
// 深拷贝：每个对象独立
class DeepCopyString {
    char* data;
    size_t length;
    // 每个对象都有自己的内存副本
};

// 引用计数：共享数据
class RefCountedString {
    struct Data {
        char* str;
        size_t length;
        int refCount;
    };
    Data* data;
    // 多个对象可以共享同一块内存
};
```

### 8. 实际应用示例

#### 8.1 自定义字符串类

```cpp
class MyString {
private:
    char* str;
    size_t length;
public:
    MyString(const char* s = "") : length(strlen(s)) {
        str = new char[length + 1];
        strcpy(str, s);
    }
    
    // 深拷贝构造函数
    MyString(const MyString& other) : length(other.length) {
        str = new char[length + 1];
        strcpy(str, other.str);
    }
    
    // 深拷贝赋值运算符
    MyString& operator=(const MyString& other) {
        if (this != &other) {
            delete[] str;
            length = other.length;
            str = new char[length + 1];
            strcpy(str, other.str);
        }
        return *this;
    }
    
    ~MyString() {
        delete[] str;
    }
    
    const char* c_str() const { return str; }
    size_t size() const { return length; }
};
```

#### 8.2 二维数组类

```cpp
class Matrix {
private:
    int** data;
    size_t rows, cols;
public:
    Matrix(size_t r, size_t c) : rows(r), cols(c) {
        data = new int*[rows];
        for (size_t i = 0; i < rows; ++i) {
            data[i] = new int[cols];
        }
    }
    
    // 深拷贝构造函数
    Matrix(const Matrix& other) : rows(other.rows), cols(other.cols) {
        data = new int*[rows];
        for (size_t i = 0; i < rows; ++i) {
            data[i] = new int[cols];
            for (size_t j = 0; j < cols; ++j) {
                data[i][j] = other.data[i][j];
            }
        }
    }
    
    // 深拷贝赋值运算符
    Matrix& operator=(const Matrix& other) {
        if (this != &other) {
            // 清理原有内存
            for (size_t i = 0; i < rows; ++i) {
                delete[] data[i];
            }
            delete[] data;
            
            // 分配新内存并复制
            rows = other.rows;
            cols = other.cols;
            data = new int*[rows];
            for (size_t i = 0; i < rows; ++i) {
                data[i] = new int[cols];
                for (size_t j = 0; j < cols; ++j) {
                    data[i][j] = other.data[i][j];
                }
            }
        }
        return *this;
    }
    
    ~Matrix() {
        for (size_t i = 0; i < rows; ++i) {
            delete[] data[i];
        }
        delete[] data;
    }
};
```

### 9. 总结

**深拷贝 vs 浅拷贝**：
- **浅拷贝**：只复制指针值，多个对象共享同一资源
- **深拷贝**：复制指针指向的内容，每个对象有独立资源

**何时需要深拷贝**：
1. 有指针成员指向动态分配内存
2. 有需要独立管理的资源
3. 需要避免对象间的相互影响

**现代C++最佳实践**：
1. 优先使用智能指针和STL容器
2. 遵循零法则（Rule of Zero）
3. 合理使用移动语义
4. 避免手动内存管理

**核心原则**：如果浅拷贝会导致资源管理问题或对象状态共享，就必须使用深拷贝。在现代C++中，尽量使用RAII和智能指针来避免手动实现深拷贝的复杂性。

---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

