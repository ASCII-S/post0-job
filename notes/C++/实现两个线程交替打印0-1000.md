---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/实现两个线程交替打印0-1000.md
related_outlines: []
---
# 实现两个线程交替打印0-1000

## 面试标准答案（可背诵）

实现两个线程交替打印需要线程同步机制来保证顺序性。常用方法有四种：**条件变量+互斥锁**（最通用，通过wait/notify实现等待唤醒）、**信号量**（C++20，通过计数控制）、**原子变量+自旋**（适合简单场景但占用CPU）、**互斥锁+标志位轮询**（效率低但易理解）。推荐使用条件变量方案：用mutex保护共享变量，用condition_variable实现线程间通信，线程通过检查轮次标志决定是否打印并唤醒对方。这种方式既高效又标准，是生产环境的首选。

---

## 一、问题分析

### 1.1 核心需求

1. **两个线程**：Thread1 和 Thread2
2. **交替打印**：Thread1 打印奇数/偶数，Thread2 打印偶数/奇数（或按任意规则交替）
3. **顺序保证**：确保打印顺序为 0, 1, 2, 3, ..., 1000
4. **线程安全**：避免数据竞争和输出混乱

### 1.2 关键技术点

- **互斥访问**：保护共享变量（当前数字）
- **线程同步**：确保交替执行的顺序
- **高效唤醒**：避免忙等待浪费CPU

---

## 二、方法一：条件变量 + 互斥锁（推荐）

### 2.1 实现代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class AlternatePrinter {
private:
    std::mutex mtx;
    std::condition_variable cv;
    int current = 0;      // 当前要打印的数字
    int turn = 0;         // 轮次标志：0表示线程0打印，1表示线程1打印
    const int max_num = 1000;

public:
    void print(int thread_id) {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            
            // 等待轮到自己
            cv.wait(lock, [this, thread_id]() {
                return turn == thread_id || current > max_num;
            });
            
            // 检查是否结束
            if (current > max_num) {
                break;
            }
            
            // 打印当前数字
            std::cout << "Thread " << thread_id << ": " << current << std::endl;
            current++;
            
            // 切换轮次
            turn = 1 - turn;
            
            // 唤醒另一个线程
            cv.notify_all();
        }
        
        // 确保另一个线程也能退出
        cv.notify_all();
    }
};

int main() {
    AlternatePrinter printer;
    
    std::thread t0(&AlternatePrinter::print, &printer, 0);
    std::thread t1(&AlternatePrinter::print, &printer, 1);
    
    t0.join();
    t1.join();
    
    return 0;
}
```

### 2.2 核心机制解析

#### 条件变量的工作流程

```cpp
// 1. 获取锁
std::unique_lock<std::mutex> lock(mtx);

// 2. 等待条件满足（自动释放锁并阻塞）
cv.wait(lock, [this, thread_id]() {
    return turn == thread_id || current > max_num;
});
// wait返回时会自动重新获取锁

// 3. 执行临界区代码
std::cout << "Thread " << thread_id << ": " << current << std::endl;
current++;
turn = 1 - turn;

// 4. 唤醒其他线程
cv.notify_all();

// 5. 释放锁（unique_lock析构时自动释放）
```

#### 为什么要用lambda谓词？

```cpp
// ❌ 错误写法：可能虚假唤醒
cv.wait(lock);
if (turn != thread_id) {
    // 可能被虚假唤醒，条件不满足
}

// ✅ 正确写法：自动处理虚假唤醒
cv.wait(lock, [this, thread_id]() {
    return turn == thread_id || current > max_num;
});
// 等价于：
// while (!(turn == thread_id || current > max_num)) {
//     cv.wait(lock);
// }
```

### 2.3 优缺点分析

**优点**：
- ✅ **高效**：线程等待时不占用CPU（阻塞状态）
- ✅ **标准**：C++11标准库，跨平台
- ✅ **灵活**：易扩展到多个线程

**缺点**：
- ❌ 代码相对复杂，需要理解条件变量机制

---

## 三、方法二：信号量（C++20）

### 3.1 实现代码

```cpp
#include <iostream>
#include <thread>
#include <semaphore>

class AlternatePrinterSemaphore {
private:
    std::counting_semaphore<1> sem0{1};  // 初始值1，线程0先执行
    std::counting_semaphore<1> sem1{0};  // 初始值0，线程1等待
    int current = 0;
    const int max_num = 1000;

public:
    void print(int thread_id) {
        auto& my_sem = (thread_id == 0) ? sem0 : sem1;
        auto& other_sem = (thread_id == 0) ? sem1 : sem0;
        
        while (current <= max_num) {
            my_sem.acquire();  // P操作：等待信号量
            
            if (current > max_num) {
                other_sem.release();  // 唤醒另一个线程以退出
                break;
            }
            
            std::cout << "Thread " << thread_id << ": " << current << std::endl;
            current++;
            
            other_sem.release();  // V操作：释放信号量，唤醒另一个线程
        }
    }
};

int main() {
    AlternatePrinterSemaphore printer;
    
    std::thread t0(&AlternatePrinterSemaphore::print, &printer, 0);
    std::thread t1(&AlternatePrinterSemaphore::print, &printer, 1);
    
    t0.join();
    t1.join();
    
    return 0;
}
```

### 3.2 信号量机制解析

#### 信号量的PV操作

```cpp
// P操作（acquire）：等待资源
sem.acquire();  // 如果计数>0，则计数-1并继续；否则阻塞等待

// V操作（release）：释放资源
sem.release();  // 计数+1，唤醒一个等待的线程
```

#### 执行流程示例

```
初始状态: sem0=1, sem1=0

时间  Thread0              Thread1              sem0  sem1
------------------------------------------------------------------
T1    acquire(sem0) ✅      acquire(sem1) ❌等待   0     0
T2    打印 0                                       0     0
T3    release(sem1)                               0     1
T4                         acquire(sem1) ✅        0     0
T5                         打印 1                  0     0
T6                         release(sem0)           1     0
T7    acquire(sem0) ✅                             0     0
T8    打印 2                                       0     0
...
```

### 3.3 优缺点分析

**优点**：
- ✅ **简洁**：代码逻辑清晰，PV操作直观
- ✅ **高效**：无忙等待，性能优秀
- ✅ **经典**：操作系统经典同步原语

**缺点**：
- ❌ **C++20**：需要较新的编译器支持
- ❌ 扩展性稍差（多线程时需要多个信号量）

---

## 四、方法三：原子变量 + 自旋等待

### 4.1 实现代码

```cpp
#include <iostream>
#include <thread>
#include <atomic>

class AlternatePrinterAtomic {
private:
    std::atomic<int> current{0};
    std::atomic<int> turn{0};
    const int max_num = 1000;

public:
    void print(int thread_id) {
        while (current.load() <= max_num) {
            // 自旋等待轮到自己
            while (turn.load() != thread_id && current.load() <= max_num) {
                std::this_thread::yield();  // 让出CPU时间片
            }
            
            if (current.load() > max_num) {
                break;
            }
            
            // 打印
            std::cout << "Thread " << thread_id << ": " << current.load() << std::endl;
            current.fetch_add(1);
            
            // 切换轮次
            turn.store(1 - thread_id);
        }
    }
};

int main() {
    AlternatePrinterAtomic printer;
    
    std::thread t0(&AlternatePrinterAtomic::print, &printer, 0);
    std::thread t1(&AlternatePrinterAtomic::print, &printer, 1);
    
    t0.join();
    t1.join();
    
    return 0;
}
```

### 4.2 原子操作解析

```cpp
// 原子读取
int val = current.load();
int val = current.load(std::memory_order_relaxed);  // 指定内存序

// 原子写入
current.store(10);
current.store(10, std::memory_order_release);

// 原子加法并返回旧值
int old_val = current.fetch_add(1);

// compare_and_swap（可选的更高级用法）
int expected = 0;
current.compare_exchange_strong(expected, 1);
```

### 4.3 优缺点分析

**优点**：
- ✅ **无锁**：避免了锁的开销
- ✅ **简单**：不需要条件变量等复杂机制

**缺点**：
- ❌ **CPU占用高**：自旋等待浪费CPU资源
- ❌ **不适合长等待**：如果等待时间长，效率低下

**适用场景**：等待时间极短的场景（微秒级）。

---

## 五、方法四：互斥锁 + 标志位轮询

### 5.1 实现代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>

class AlternatePrinterMutex {
private:
    std::mutex mtx;
    int current = 0;
    int turn = 0;
    const int max_num = 1000;

public:
    void print(int thread_id) {
        while (true) {
            mtx.lock();
            
            if (current > max_num) {
                mtx.unlock();
                break;
            }
            
            if (turn == thread_id) {
                std::cout << "Thread " << thread_id << ": " << current << std::endl;
                current++;
                turn = 1 - turn;
            }
            
            mtx.unlock();
            
            // 避免过度竞争锁
            std::this_thread::sleep_for(std::chrono::microseconds(1));
        }
    }
};

int main() {
    AlternatePrinterMutex printer;
    
    std::thread t0(&AlternatePrinterMutex::print, &printer, 0);
    std::thread t1(&AlternatePrinterMutex::print, &printer, 1);
    
    t0.join();
    t1.join();
    
    return 0;
}
```

### 5.2 优缺点分析

**优点**：
- ✅ **易理解**：逻辑最简单直观

**缺点**：
- ❌ **效率低**：频繁加锁解锁，且轮询浪费资源
- ❌ **不推荐**：生产环境应避免

---

## 六、扩展：奇偶线程打印

### 6.1 需求变化

- Thread1 打印所有偶数：0, 2, 4, ..., 1000
- Thread2 打印所有奇数：1, 3, 5, ..., 999

### 6.2 实现代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class OddEvenPrinter {
private:
    std::mutex mtx;
    std::condition_variable cv;
    int current = 0;
    const int max_num = 1000;

public:
    // 打印偶数
    void print_even() {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            
            // 等待当前数字是偶数
            cv.wait(lock, [this]() {
                return current % 2 == 0 || current > max_num;
            });
            
            if (current > max_num) {
                break;
            }
            
            std::cout << "Even Thread: " << current << std::endl;
            current++;
            
            cv.notify_all();
        }
        cv.notify_all();
    }
    
    // 打印奇数
    void print_odd() {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            
            // 等待当前数字是奇数
            cv.wait(lock, [this]() {
                return current % 2 == 1 || current > max_num;
            });
            
            if (current > max_num) {
                break;
            }
            
            std::cout << "Odd Thread: " << current << std::endl;
            current++;
            
            cv.notify_all();
        }
        cv.notify_all();
    }
};

int main() {
    OddEvenPrinter printer;
    
    std::thread t_even(&OddEvenPrinter::print_even, &printer);
    std::thread t_odd(&OddEvenPrinter::print_odd, &printer);
    
    t_even.join();
    t_odd.join();
    
    return 0;
}
```

---

## 七、扩展：三个或多个线程交替打印

### 7.1 三线程版本

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

class MultiThreadPrinter {
private:
    std::mutex mtx;
    std::condition_variable cv;
    int current = 0;
    int turn = 0;  // 当前轮到哪个线程
    const int max_num = 1000;
    const int num_threads;

public:
    MultiThreadPrinter(int n) : num_threads(n) {}
    
    void print(int thread_id) {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            
            cv.wait(lock, [this, thread_id]() {
                return turn == thread_id || current > max_num;
            });
            
            if (current > max_num) {
                break;
            }
            
            std::cout << "Thread " << thread_id << ": " << current << std::endl;
            current++;
            
            // 循环切换到下一个线程
            turn = (turn + 1) % num_threads;
            
            cv.notify_all();
        }
        cv.notify_all();
    }
};

int main() {
    const int N = 3;  // 3个线程
    MultiThreadPrinter printer(N);
    
    std::vector<std::thread> threads;
    for (int i = 0; i < N; ++i) {
        threads.emplace_back(&MultiThreadPrinter::print, &printer, i);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    return 0;
}
```

---

## 八、性能对比与选择建议

### 8.1 性能对比

| 方法            | CPU占用  | 响应延迟 | 代码复杂度 | 扩展性  | 推荐度 |
| --------------- | -------- | -------- | ---------- | ------- | ------ |
| 条件变量+互斥锁 | ⭐ 低     | ⭐⭐ 中    | ⭐⭐⭐ 中     | ⭐⭐⭐ 好  | ⭐⭐⭐⭐⭐  |
| 信号量          | ⭐ 低     | ⭐⭐ 中    | ⭐⭐ 简单    | ⭐⭐ 一般 | ⭐⭐⭐⭐   |
| 原子变量+自旋   | ⭐⭐⭐⭐ 高  | ⭐ 低     | ⭐ 简单     | ⭐⭐ 一般 | ⭐⭐     |
| 互斥锁+轮询     | ⭐⭐⭐ 中高 | ⭐⭐⭐ 高   | ⭐ 简单     | ⭐ 差    | ⭐      |

### 8.2 选择建议

```cpp
// 场景1：通用生产环境 → 条件变量
// 理由：标准、高效、可维护

// 场景2：C++20环境，简单场景 → 信号量
// 理由：代码简洁，性能优秀

// 场景3：极低延迟要求（如高频交易） → 原子变量
// 理由：响应快，但需注意CPU占用

// 场景4：学习演示 → 任意方法
// 理由：理解多种同步机制
```

---

## 九、常见问题与调试

### 9.1 死锁问题

```cpp
// ❌ 可能死锁：两个线程都在等待
cv.wait(lock, [this, thread_id]() {
    return turn == thread_id;  // 缺少退出条件
});

// ✅ 正确：添加退出条件
cv.wait(lock, [this, thread_id]() {
    return turn == thread_id || current > max_num;
});
```

### 9.2 虚假唤醒

```cpp
// ❌ 错误：可能虚假唤醒
cv.wait(lock);
if (turn == thread_id) {
    // ...
}

// ✅ 正确：使用谓词自动处理
cv.wait(lock, [this, thread_id]() {
    return turn == thread_id || current > max_num;
});
```

### 9.3 输出混乱

```cpp
// 问题：std::cout不是线程安全的
std::cout << "Thread " << thread_id << ": " << current << std::endl;

// 可能输出：
// Thread Thread 0: 1: 02
// 

// 解决方案1：使用互斥锁保护输出
{
    std::lock_guard<std::mutex> output_lock(output_mtx);
    std::cout << "Thread " << thread_id << ": " << current << std::endl;
}

// 解决方案2：使用字符串流
std::ostringstream oss;
oss << "Thread " << thread_id << ": " << current << "\n";
std::cout << oss.str();  // 单次输出

// 解决方案3：C++20 std::osyncstream
std::osyncstream(std::cout) << "Thread " << thread_id << ": " << current << "\n";
```

### 9.4 线程退出问题

```cpp
// 问题：一个线程退出后，另一个线程可能永久等待
void print(int thread_id) {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this, thread_id]() {
            return turn == thread_id;  // 缺少退出条件
        });
        
        if (current > max_num) {
            break;  // 线程退出，但没有唤醒其他线程！
        }
        // ...
    }
}

// 解决：退出前唤醒其他线程
void print(int thread_id) {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this, thread_id]() {
            return turn == thread_id || current > max_num;
        });
        
        if (current > max_num) {
            break;
        }
        // ...
    }
    cv.notify_all();  // ✅ 确保其他线程也能退出
}
```

---

## 十、面试延伸问题

### 10.1 如何保证线程安全？

**回答要点**：
1. 使用互斥锁保护共享变量
2. 使用条件变量或信号量同步线程
3. 确保原子操作的完整性
4. 避免数据竞争（data race）

### 10.2 如果要打印到100万怎么办？

**回答要点**：
- 条件变量方案仍然适用
- 考虑使用`unsigned int`或`long long`
- 注意`std::cout`的性能瓶颈，可以批量输出
- 可以使用无锁队列进一步优化

### 10.3 如何扩展到N个线程？

**回答**：使用取模运算实现循环轮转（见第七节代码）

### 10.4 为什么不用`join()`控制顺序？

```cpp
// ❌ 错误理解：用join控制顺序
t0.join();  // 等待t0结束
t1.join();  // 等待t1结束
// join只是等待线程结束，不能控制执行顺序！

// ✅ 正确：用同步原语控制顺序
```

---

## 十一、总结与最佳实践

### 11.1 核心要点

1. **条件变量是首选**：标准、高效、易维护
2. **避免忙等待**：浪费CPU资源
3. **处理边界条件**：确保所有线程都能正常退出
4. **注意虚假唤醒**：使用谓词形式的`wait()`

### 11.2 代码模板（推荐背诵）

```cpp
class AlternatePrinter {
private:
    std::mutex mtx;
    std::condition_variable cv;
    int current = 0;
    int turn = 0;
    const int max_num = 1000;

public:
    void print(int thread_id) {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            
            // 等待条件：轮到自己 或 任务结束
            cv.wait(lock, [this, thread_id]() {
                return turn == thread_id || current > max_num;
            });
            
            // 检查退出条件
            if (current > max_num) break;
            
            // 执行任务
            std::cout << "Thread " << thread_id << ": " << current << std::endl;
            current++;
            turn = 1 - turn;
            
            // 唤醒其他线程
            cv.notify_all();
        }
        cv.notify_all();  // 确保其他线程退出
    }
};
```

### 11.3 检查清单

- [ ] 是否使用了线程安全的同步机制？
- [ ] 是否处理了虚假唤醒？
- [ ] 所有线程是否都能正常退出？
- [ ] 是否避免了死锁？
- [ ] 输出是否会混乱？
- [ ] 是否考虑了性能和资源消耗？

---

## 参考资源

- C++ Concurrency in Action (2nd Edition) - Anthony Williams
- C++11/14/17/20标准库 `<thread>`, `<mutex>`, `<condition_variable>`, `<semaphore>`
- cppreference.com - Thread support library


---

## 相关笔记
<!-- 自动生成 -->

- [生产者-消费者模式的实现](notes/C++/生产者-消费者模式的实现.md) - 相似度: 36% | 标签: C++, C++/生产者-消费者模式的实现.md
- [condition_variable的使用模式](notes/C++/condition_variable的使用模式.md) - 相似度: 31% | 标签: C++, C++/condition_variable的使用模式.md

